# 智能任务管理页面详细设计文档

## 1. 页面概述

智能任务管理页面是项目管理平台的核心功能模块，集成了AI技术来优化任务分配、进度跟踪和团队协作。该页面通过LangChain和LangGraph技术提供智能任务推荐、自动化工作流程和预测性分析，帮助团队提高工作效率和项目成功率。

## 2. 功能需求

### 2.1 核心功能
- **智能任务创建**: AI辅助任务分解、优先级设定和工作量估算
- **任务分配优化**: 基于团队成员技能、工作负载和历史表现的智能分配
- **进度跟踪**: 实时任务状态监控和进度预测
- **工作流自动化**: 自定义规则引擎和状态自动流转
- **协作增强**: 智能提醒、依赖关系管理和冲突检测

### 2.2 用户角色权限
- **普通用户**: 查看和更新分配给自己的任务，创建子任务
- **项目管理员**: 创建、分配、修改任务，查看团队任务概览
- **系统管理员**: 配置工作流规则，管理任务模板和自动化设置

## 3. 前端设计

### 3.1 页面布局

```typescript
// 页面布局结构
interface TaskManagementLayout {
  header: {
    projectSelector: ProjectSelectorComponent;
    viewToggle: ViewToggleComponent; // 列表视图、看板视图、甘特图
    filterPanel: FilterPanelComponent;
    aiAssistant: AIAssistantButtonComponent;
  };
  sidebar: {
    taskFilters: TaskFiltersComponent;
    quickActions: QuickActionsComponent;
    aiSuggestions: AISuggestionsComponent;
  };
  mainArea: {
    taskBoard?: KanbanBoardComponent;
    taskList?: TaskListComponent;
    ganttChart?: GanttChartComponent;
    taskDetails?: TaskDetailsComponent;
  };
  rightPanel?: {
    taskForm: TaskFormComponent;
    aiRecommendations: AIRecommendationsComponent;
    activityFeed: ActivityFeedComponent;
  };
}
```

### 3.2 UI组件设计

#### 3.2.1 智能任务卡片组件
```typescript
// SmartTaskCard.tsx
interface TaskCardProps {
  task: Task;
  onUpdate: (taskId: string, updates: Partial<Task>) => void;
  onAssign: (taskId: string, assigneeId: string) => void;
  aiSuggestions?: {
    priority: string;
    estimatedHours: number;
    recommendedAssignee: string;
    dependencies: string[];
  };
  draggable?: boolean;
}

const SmartTaskCard: React.FC<TaskCardProps> = ({
  task,
  onUpdate,
  onAssign,
  aiSuggestions,
  draggable = false
}) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const [showAISuggestions, setShowAISuggestions] = useState(false);
  
  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'HIGH': return 'border-l-red-500 bg-red-50';
      case 'MEDIUM': return 'border-l-yellow-500 bg-yellow-50';
      case 'LOW': return 'border-l-green-500 bg-green-50';
      default: return 'border-l-gray-500 bg-gray-50';
    }
  };
  
  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'TODO': return <Circle className="w-4 h-4 text-gray-500" />;
      case 'IN_PROGRESS': return <Clock className="w-4 h-4 text-blue-500" />;
      case 'REVIEW': return <Eye className="w-4 h-4 text-yellow-500" />;
      case 'DONE': return <CheckCircle className="w-4 h-4 text-green-500" />;
      default: return <Circle className="w-4 h-4 text-gray-500" />;
    }
  };
  
  return (
    <Card 
      className={cn(
        "p-4 border-l-4 transition-all duration-200 hover:shadow-md",
        getPriorityColor(task.priority),
        draggable && "cursor-move"
      )}
      draggable={draggable}
    >
      <div className="space-y-3">
        {/* 任务头部 */}
        <div className="flex items-start justify-between">
          <div className="flex items-center gap-2">
            {getStatusIcon(task.status)}
            <h3 className="font-medium text-sm line-clamp-2">
              {task.title}
            </h3>
          </div>
          
          <div className="flex items-center gap-1">
            {aiSuggestions && (
              <Button
                variant="ghost"
                size="sm"
                onClick={() => setShowAISuggestions(!showAISuggestions)}
                className="p-1"
              >
                <Brain className="w-4 h-4 text-purple-500" />
              </Button>
            )}
            
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="sm" className="p-1">
                  <MoreHorizontal className="w-4 h-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent>
                <DropdownMenuItem onClick={() => setIsExpanded(!isExpanded)}>
                  <Eye className="w-4 h-4 mr-2" />
                  查看详情
                </DropdownMenuItem>
                <DropdownMenuItem>
                  <Edit className="w-4 h-4 mr-2" />
                  编辑任务
                </DropdownMenuItem>
                <DropdownMenuItem>
                  <Users className="w-4 h-4 mr-2" />
                  重新分配
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
        
        {/* AI建议面板 */}
        {showAISuggestions && aiSuggestions && (
          <div className="bg-purple-50 border border-purple-200 rounded-lg p-3 space-y-2">
            <div className="flex items-center gap-2 text-purple-700 font-medium text-xs">
              <Sparkles className="w-3 h-3" />
              AI建议
            </div>
            
            <div className="space-y-1 text-xs">
              {aiSuggestions.priority !== task.priority && (
                <div className="flex items-center justify-between">
                  <span>建议优先级:</span>
                  <Badge variant="outline" className="text-xs">
                    {aiSuggestions.priority}
                  </Badge>
                </div>
              )}
              
              {aiSuggestions.estimatedHours && (
                <div className="flex items-center justify-between">
                  <span>预估工时:</span>
                  <span className="font-medium">{aiSuggestions.estimatedHours}h</span>
                </div>
              )}
              
              {aiSuggestions.recommendedAssignee && (
                <div className="flex items-center justify-between">
                  <span>推荐负责人:</span>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-auto p-1 text-xs"
                    onClick={() => onAssign(task.id, aiSuggestions.recommendedAssignee)}
                  >
                    应用建议
                  </Button>
                </div>
              )}
            </div>
          </div>
        )}
        
        {/* 任务描述 */}
        {task.description && (
          <p className="text-xs text-gray-600 line-clamp-2">
            {task.description}
          </p>
        )}
        
        {/* 任务元信息 */}
        <div className="flex items-center justify-between text-xs text-gray-500">
          <div className="flex items-center gap-2">
            {task.assignee && (
              <div className="flex items-center gap-1">
                <Avatar className="w-5 h-5">
                  <AvatarImage src={task.assignee.avatar} />
                  <AvatarFallback className="text-xs">
                    {task.assignee.name.charAt(0)}
                  </AvatarFallback>
                </Avatar>
                <span>{task.assignee.name}</span>
              </div>
            )}
            
            {task.dueDate && (
              <div className={cn(
                "flex items-center gap-1",
                new Date(task.dueDate) < new Date() && "text-red-500"
              )}>
                <Calendar className="w-3 h-3" />
                <span>{format(new Date(task.dueDate), 'MM/dd')}</span>
              </div>
            )}
          </div>
          
          <div className="flex items-center gap-1">
            {task.storyPoints && (
              <Badge variant="secondary" className="text-xs">
                {task.storyPoints}sp
              </Badge>
            )}
            
            {task.tags?.map((tag) => (
              <Badge key={tag} variant="outline" className="text-xs">
                {tag}
              </Badge>
            ))}
          </div>
        </div>
        
        {/* 进度条 */}
        {task.progress !== undefined && (
          <div className="space-y-1">
            <div className="flex justify-between text-xs">
              <span>进度</span>
              <span>{task.progress}%</span>
            </div>
            <Progress value={task.progress} className="h-1" />
          </div>
        )}
        
        {/* 展开详情 */}
        {isExpanded && (
          <div className="border-t pt-3 space-y-2">
            {task.subtasks && task.subtasks.length > 0 && (
              <div>
                <div className="text-xs font-medium mb-1">子任务 ({task.subtasks.length})</div>
                <div className="space-y-1">
                  {task.subtasks.slice(0, 3).map((subtask) => (
                    <div key={subtask.id} className="flex items-center gap-2 text-xs">
                      <Checkbox 
                        checked={subtask.status === 'DONE'}
                        onCheckedChange={(checked) => {
                          onUpdate(subtask.id, { 
                            status: checked ? 'DONE' : 'TODO' 
                          });
                        }}
                      />
                      <span className={cn(
                        subtask.status === 'DONE' && "line-through text-gray-500"
                      )}>
                        {subtask.title}
                      </span>
                    </div>
                  ))}
                  {task.subtasks.length > 3 && (
                    <div className="text-xs text-gray-500">
                      +{task.subtasks.length - 3} 更多
                    </div>
                  )}
                </div>
              </div>
            )}
            
            {task.dependencies && task.dependencies.length > 0 && (
              <div>
                <div className="text-xs font-medium mb-1">依赖任务</div>
                <div className="flex flex-wrap gap-1">
                  {task.dependencies.map((dep) => (
                    <Badge key={dep.id} variant="outline" className="text-xs">
                      {dep.title}
                    </Badge>
                  ))}
                </div>
              </div>
            )}
            
            {task.comments && task.comments.length > 0 && (
              <div>
                <div className="text-xs font-medium mb-1">
                  最新评论 ({task.comments.length})
                </div>
                <div className="text-xs text-gray-600">
                  {task.comments[0].content.slice(0, 100)}...
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    </Card>
  );
};
```

#### 3.2.2 看板视图组件
```typescript
// KanbanBoard.tsx
interface KanbanBoardProps {
  tasks: Task[];
  columns: {
    id: string;
    title: string;
    status: string;
    color: string;
    limit?: number;
  }[];
  onTaskMove: (taskId: string, newStatus: string, newIndex: number) => void;
  onTaskUpdate: (taskId: string, updates: Partial<Task>) => void;
  loading?: boolean;
}

const KanbanBoard: React.FC<KanbanBoardProps> = ({
  tasks,
  columns,
  onTaskMove,
  onTaskUpdate,
  loading
}) => {
  const [draggedTask, setDraggedTask] = useState<Task | null>(null);
  const [aiSuggestions, setAiSuggestions] = useState<Record<string, any>>({});
  
  // 获取AI建议
  const fetchAISuggestions = useCallback(async (taskId: string) => {
    try {
      const response = await fetch('/api/ai/tasks/suggestions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ taskId })
      });
      
      const suggestions = await response.json();
      setAiSuggestions(prev => ({ ...prev, [taskId]: suggestions }));
    } catch (error) {
      console.error('获取AI建议失败:', error);
    }
  }, []);
  
  const handleDragStart = (task: Task) => {
    setDraggedTask(task);
    fetchAISuggestions(task.id);
  };
  
  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
  };
  
  const handleDrop = (e: React.DragEvent, columnStatus: string) => {
    e.preventDefault();
    
    if (draggedTask && draggedTask.status !== columnStatus) {
      const columnTasks = tasks.filter(t => t.status === columnStatus);
      onTaskMove(draggedTask.id, columnStatus, columnTasks.length);
    }
    
    setDraggedTask(null);
  };
  
  const getColumnTasks = (status: string) => {
    return tasks.filter(task => task.status === status);
  };
  
  const isColumnOverLimit = (column: any) => {
    if (!column.limit) return false;
    return getColumnTasks(column.status).length >= column.limit;
  };
  
  if (loading) {
    return (
      <div className="flex gap-6 h-full">
        {columns.map((column) => (
          <div key={column.id} className="flex-1 space-y-4">
            <div className="h-8 bg-gray-200 rounded animate-pulse" />
            {Array.from({ length: 3 }).map((_, index) => (
              <div key={index} className="h-32 bg-gray-100 rounded animate-pulse" />
            ))}
          </div>
        ))}
      </div>
    );
  }
  
  return (
    <div className="flex gap-6 h-full overflow-x-auto">
      {columns.map((column) => {
        const columnTasks = getColumnTasks(column.status);
        const isOverLimit = isColumnOverLimit(column);
        
        return (
          <div
            key={column.id}
            className="flex-1 min-w-80 space-y-4"
            onDragOver={handleDragOver}
            onDrop={(e) => handleDrop(e, column.status)}
          >
            {/* 列头 */}
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <div 
                  className="w-3 h-3 rounded-full"
                  style={{ backgroundColor: column.color }}
                />
                <h3 className="font-medium">{column.title}</h3>
                <Badge variant="secondary" className="text-xs">
                  {columnTasks.length}
                  {column.limit && `/${column.limit}`}
                </Badge>
              </div>
              
              {isOverLimit && (
                <div className="flex items-center gap-1 text-red-500">
                  <AlertTriangle className="w-4 h-4" />
                  <span className="text-xs">超出限制</span>
                </div>
              )}
            </div>
            
            {/* 任务列表 */}
            <div className={cn(
              "space-y-3 min-h-96 p-3 rounded-lg border-2 border-dashed transition-colors",
              draggedTask && "border-blue-300 bg-blue-50",
              isOverLimit && "border-red-300 bg-red-50",
              !draggedTask && !isOverLimit && "border-gray-200"
            )}>
              {columnTasks.map((task) => (
                <div
                  key={task.id}
                  onDragStart={() => handleDragStart(task)}
                  onDragEnd={() => setDraggedTask(null)}
                >
                  <SmartTaskCard
                    task={task}
                    onUpdate={onTaskUpdate}
                    onAssign={(taskId, assigneeId) => {
                      onTaskUpdate(taskId, { assigneeId });
                    }}
                    aiSuggestions={aiSuggestions[task.id]}
                    draggable
                  />
                </div>
              ))}
              
              {columnTasks.length === 0 && (
                <div className="text-center py-8 text-gray-500">
                  <Package className="w-8 h-8 mx-auto mb-2 opacity-50" />
                  <p className="text-sm">暂无任务</p>
                </div>
              )}
            </div>
            
            {/* 快速添加任务 */}
            <Button
              variant="ghost"
              className="w-full justify-start text-gray-500 hover:text-gray-700"
              onClick={() => {
                // 打开任务创建表单，预设状态为当前列
              }}
            >
              <Plus className="w-4 h-4 mr-2" />
              添加任务
            </Button>
          </div>
        );
      })}
    </div>
  );
};
```

#### 3.2.3 AI任务助手组件
```typescript
// AITaskAssistant.tsx
interface AITaskAssistantProps {
  projectId: string;
  onTaskCreate: (task: Partial<Task>) => void;
  onWorkflowSuggestion: (suggestion: WorkflowSuggestion) => void;
}

const AITaskAssistant: React.FC<AITaskAssistantProps> = ({
  projectId,
  onTaskCreate,
  onWorkflowSuggestion
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [input, setInput] = useState('');
  const [suggestions, setSuggestions] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  
  const generateTaskSuggestions = async (description: string) => {
    if (!description.trim()) return;
    
    setLoading(true);
    try {
      const response = await fetch('/api/ai/tasks/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          projectId,
          description,
          context: 'task_creation'
        })
      });
      
      const result = await response.json();
      setSuggestions(result.suggestions || []);
    } catch (error) {
      console.error('生成任务建议失败:', error);
    } finally {
      setLoading(false);
    }
  };
  
  const handleInputSubmit = () => {
    generateTaskSuggestions(input);
  };
  
  const handleTaskAccept = (suggestion: any) => {
    onTaskCreate({
      title: suggestion.title,
      description: suggestion.description,
      priority: suggestion.priority,
      estimatedHours: suggestion.estimatedHours,
      tags: suggestion.tags,
      assigneeId: suggestion.recommendedAssignee
    });
    
    setInput('');
    setSuggestions([]);
  };
  
  return (
    <>
      {/* AI助手触发按钮 */}
      <Button
        onClick={() => setIsOpen(true)}
        className="fixed bottom-6 right-6 rounded-full w-14 h-14 shadow-lg"
        size="lg"
      >
        <Brain className="w-6 h-6" />
      </Button>
      
      {/* AI助手对话框 */}
      <Dialog open={isOpen} onOpenChange={setIsOpen}>
        <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2">
              <Sparkles className="w-5 h-5 text-purple-500" />
              AI任务助手
            </DialogTitle>
            <DialogDescription>
              描述您想要创建的任务，AI将为您生成详细的任务建议
            </DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4">
            {/* 输入区域 */}
            <div className="space-y-2">
              <Label htmlFor="task-description">任务描述</Label>
              <Textarea
                id="task-description"
                placeholder="例如：创建用户登录功能，包括前端界面和后端API"
                value={input}
                onChange={(e) => setInput(e.target.value)}
                rows={3}
              />
              <Button 
                onClick={handleInputSubmit}
                disabled={!input.trim() || loading}
                className="w-full"
              >
                {loading ? (
                  <>
                    <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    生成建议中...
                  </>
                ) : (
                  <>
                    <Wand2 className="w-4 h-4 mr-2" />
                    生成任务建议
                  </>
                )}
              </Button>
            </div>
            
            {/* AI建议列表 */}
            {suggestions.length > 0 && (
              <div className="space-y-3">
                <h4 className="font-medium flex items-center gap-2">
                  <Lightbulb className="w-4 h-4 text-yellow-500" />
                  AI建议的任务
                </h4>
                
                {suggestions.map((suggestion, index) => (
                  <Card key={index} className="p-4">
                    <div className="space-y-3">
                      <div className="flex items-start justify-between">
                        <div className="flex-1">
                          <h5 className="font-medium">{suggestion.title}</h5>
                          <p className="text-sm text-gray-600 mt-1">
                            {suggestion.description}
                          </p>
                        </div>
                        
                        <Button
                          size="sm"
                          onClick={() => handleTaskAccept(suggestion)}
                        >
                          采用
                        </Button>
                      </div>
                      
                      <div className="flex items-center gap-4 text-sm text-gray-500">
                        <div className="flex items-center gap-1">
                          <Flag className="w-3 h-3" />
                          <span>优先级: {suggestion.priority}</span>
                        </div>
                        
                        {suggestion.estimatedHours && (
                          <div className="flex items-center gap-1">
                            <Clock className="w-3 h-3" />
                            <span>预估: {suggestion.estimatedHours}h</span>
                          </div>
                        )}
                        
                        {suggestion.recommendedAssignee && (
                          <div className="flex items-center gap-1">
                            <User className="w-3 h-3" />
                            <span>推荐: {suggestion.recommendedAssignee}</span>
                          </div>
                        )}
                      </div>
                      
                      {suggestion.subtasks && suggestion.subtasks.length > 0 && (
                        <div>
                          <div className="text-sm font-medium mb-1">建议的子任务:</div>
                          <ul className="text-sm text-gray-600 space-y-1">
                            {suggestion.subtasks.map((subtask: string, idx: number) => (
                              <li key={idx} className="flex items-center gap-2">
                                <div className="w-1 h-1 bg-gray-400 rounded-full" />
                                {subtask}
                              </li>
                            ))}
                          </ul>
                        </div>
                      )}
                      
                      {suggestion.tags && suggestion.tags.length > 0 && (
                        <div className="flex flex-wrap gap-1">
                          {suggestion.tags.map((tag: string) => (
                            <Badge key={tag} variant="outline" className="text-xs">
                              {tag}
                            </Badge>
                          ))}
                        </div>
                      )}
                    </div>
                  </Card>
                ))}
              </div>
            )}
            
            {/* 快速操作建议 */}
            <div className="border-t pt-4">
              <h4 className="font-medium mb-2">快速操作</h4>
              <div className="grid grid-cols-2 gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => generateTaskSuggestions('分析当前项目进度并生成状态报告')}
                >
                  <BarChart3 className="w-4 h-4 mr-2" />
                  生成进度报告
                </Button>
                
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => generateTaskSuggestions('优化团队工作流程和任务分配')}
                >
                  <Workflow className="w-4 h-4 mr-2" />
                  优化工作流
                </Button>
                
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => generateTaskSuggestions('识别项目风险并制定应对措施')}
                >
                  <Shield className="w-4 h-4 mr-2" />
                  风险分析
                </Button>
                
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => generateTaskSuggestions('安排下周的团队任务和会议')}
                >
                  <Calendar className="w-4 h-4 mr-2" />
                  周计划
                </Button>
              </div>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </>
  );
};
```

### 3.3 状态管理

```typescript
// useTaskStore.ts
interface TaskState {
  tasks: Task[];
  selectedProject: Project | null;
  currentView: 'kanban' | 'list' | 'gantt';
  filters: {
    status: string[];
    assignee: string[];
    priority: string[];
    tags: string[];
    dateRange: { start: Date | null; end: Date | null };
  };
  loading: {
    tasks: boolean;
    creating: boolean;
    updating: boolean;
  };
  aiSuggestions: {
    taskRecommendations: any[];
    workflowOptimizations: any[];
    riskAlerts: any[];
  };
  error: string | null;
}

interface TaskActions {
  loadTasks: (projectId: string) => Promise<void>;
  createTask: (task: Partial<Task>) => Promise<void>;
  updateTask: (taskId: string, updates: Partial<Task>) => Promise<void>;
  deleteTask: (taskId: string) => Promise<void>;
  moveTask: (taskId: string, newStatus: string, newIndex: number) => Promise<void>;
  assignTask: (taskId: string, assigneeId: string) => Promise<void>;
  setFilters: (filters: Partial<TaskState['filters']>) => void;
  setCurrentView: (view: TaskState['currentView']) => void;
  generateAISuggestions: (context: string) => Promise<void>;
  applyAISuggestion: (suggestionId: string) => Promise<void>;
}

export const useTaskStore = create<TaskState & TaskActions>((set, get) => ({
  tasks: [],
  selectedProject: null,
  currentView: 'kanban',
  filters: {
    status: [],
    assignee: [],
    priority: [],
    tags: [],
    dateRange: { start: null, end: null }
  },
  loading: {
    tasks: false,
    creating: false,
    updating: false
  },
  aiSuggestions: {
    taskRecommendations: [],
    workflowOptimizations: [],
    riskAlerts: []
  },
  error: null,

  loadTasks: async (projectId: string) => {
    set(state => ({ loading: { ...state.loading, tasks: true } }));
    
    try {
      const response = await fetch(`/api/projects/${projectId}/tasks`, {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (!response.ok) throw new Error('Failed to load tasks');
      
      const tasks = await response.json();
      set({ tasks, error: null });
    } catch (error) {
      set({ error: '加载任务失败' });
    } finally {
      set(state => ({ loading: { ...state.loading, tasks: false } }));
    }
  },

  createTask: async (taskData: Partial<Task>) => {
    set(state => ({ loading: { ...state.loading, creating: true } }));
    
    try {
      const response = await fetch('/api/tasks', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(taskData)
      });
      
      if (!response.ok) throw new Error('Failed to create task');
      
      const newTask = await response.json();
      set(state => ({ 
        tasks: [...state.tasks, newTask],
        error: null
      }));
    } catch (error) {
      set({ error: '创建任务失败' });
    } finally {
      set(state => ({ loading: { ...state.loading, creating: false } }));
    }
  },

  updateTask: async (taskId: string, updates: Partial<Task>) => {
    set(state => ({ loading: { ...state.loading, updating: true } }));
    
    try {
      const response = await fetch(`/api/tasks/${taskId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });
      
      if (!response.ok) throw new Error('Failed to update task');
      
      const updatedTask = await response.json();
      set(state => ({
        tasks: state.tasks.map(task => 
          task.id === taskId ? { ...task, ...updatedTask } : task
        ),
        error: null
      }));
    } catch (error) {
      set({ error: '更新任务失败' });
    } finally {
      set(state => ({ loading: { ...state.loading, updating: false } }));
    }
  },

  moveTask: async (taskId: string, newStatus: string, newIndex: number) => {
    // 乐观更新
    const { tasks } = get();
    const taskToMove = tasks.find(t => t.id === taskId);
    if (!taskToMove) return;
    
    const updatedTasks = tasks.map(task => 
      task.id === taskId ? { ...task, status: newStatus } : task
    );
    set({ tasks: updatedTasks });
    
    try {
      const response = await fetch(`/api/tasks/${taskId}/move`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status: newStatus, index: newIndex })
      });
      
      if (!response.ok) {
        // 回滚更新
        set({ tasks });
        throw new Error('Failed to move task');
      }
    } catch (error) {
      set({ error: '移动任务失败' });
    }
  },

  assignTask: async (taskId: string, assigneeId: string) => {
    try {
      const response = await fetch(`/api/tasks/${taskId}/assign`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ assigneeId })
      });
      
      if (!response.ok) throw new Error('Failed to assign task');
      
      const updatedTask = await response.json();
      set(state => ({
        tasks: state.tasks.map(task => 
          task.id === taskId ? { ...task, ...updatedTask } : task
        )
      }));
    } catch (error) {
      set({ error: '分配任务失败' });
    }
  },

  setFilters: (newFilters) => {
    set(state => ({
      filters: { ...state.filters, ...newFilters }
    }));
  },

  setCurrentView: (view) => {
    set({ currentView: view });
  },

  generateAISuggestions: async (context: string) => {
    try {
      const { selectedProject, tasks } = get();
      if (!selectedProject) return;
      
      const response = await fetch('/api/ai/tasks/suggestions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          projectId: selectedProject.id,
          context,
          tasks: tasks.map(t => ({ id: t.id, status: t.status, priority: t.priority }))
        })
      });
      
      if (!response.ok) throw new Error('Failed to generate suggestions');
      
      const suggestions = await response.json();
      set(state => ({
        aiSuggestions: {
          ...state.aiSuggestions,
          ...suggestions
        }
      }));
    } catch (error) {
      console.error('生成AI建议失败:', error);
    }
  },

  applyAISuggestion: async (suggestionId: string) => {
    try {
      const response = await fetch('/api/ai/suggestions/apply', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ suggestionId })
      });
      
      if (!response.ok) throw new Error('Failed to apply suggestion');
      
      // 重新加载任务以反映更改
      const { selectedProject } = get();
      if (selectedProject) {
        get().loadTasks(selectedProject.id);
      }
    } catch (error) {
      set({ error: '应用建议失败' });
    }
  }
}));
```

### 3.4 实时协作

```typescript
// useRealtimeTask.ts
export const useRealtimeTask = (projectId?: string) => {
  const { tasks, updateTask, loadTasks } = useTaskStore();
  const { socket, isConnected } = useWebSocket();
  
  useEffect(() => {
    if (!socket || !projectId) return;
    
    // 加入项目任务房间
    socket.emit('join_project_tasks', { projectId });
    
    // 监听任务更新
    socket.on('task_updated', (data: { taskId: string; updates: Partial<Task> }) => {
      updateTask(data.taskId, data.updates);
    });
    
    // 监听任务创建
    socket.on('task_created', (task: Task) => {
      useTaskStore.setState(state => ({
        tasks: [...state.tasks, task]
      }));
    });
    
    // 监听任务删除
    socket.on('task_deleted', (data: { taskId: string }) => {
      useTaskStore.setState(state => ({
        tasks: state.tasks.filter(t => t.id !== data.taskId)
      }));
    });
    
    // 监听任务移动
    socket.on('task_moved', (data: { taskId: string; newStatus: string }) => {
      updateTask(data.taskId, { status: data.newStatus });
    });
    
    // 监听用户正在编辑的任务
    socket.on('task_editing', (data: { taskId: string; userId: string; userName: string }) => {
      // 显示其他用户正在编辑的提示
      showEditingIndicator(data.taskId, data.userName);
    });
    
    return () => {
      socket.off('task_updated');
      socket.off('task_created');
      socket.off('task_deleted');
      socket.off('task_moved');
      socket.off('task_editing');
      socket.emit('leave_project_tasks', { projectId });
    };
  }, [socket, projectId]);
  
  const broadcastTaskEdit = useCallback((taskId: string) => {
    if (socket) {
      socket.emit('start_task_editing', { taskId, projectId });
    }
  }, [socket, projectId]);
  
  const stopTaskEdit = useCallback((taskId: string) => {
    if (socket) {
      socket.emit('stop_task_editing', { taskId, projectId });
    }
  }, [socket, projectId]);
  
  return {
    isConnected,
    broadcastTaskEdit,
    stopTaskEdit
  };
};

const showEditingIndicator = (taskId: string, userName: string) => {
  // 实现编辑指示器的显示逻辑
  const indicator = document.createElement('div');
  indicator.className = 'editing-indicator';
  indicator.textContent = `${userName} 正在编辑...`;
  
  const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
  if (taskElement) {
    taskElement.appendChild(indicator);
    
    // 3秒后自动移除指示器
    setTimeout(() => {
      if (indicator.parentNode) {
        indicator.parentNode.removeChild(indicator);
      }
    }, 3000);
  }
};
```

## 4. 后端API设计

### 4.1 API接口定义

#### 4.1.1 任务管理接口
```typescript
// /api/tasks - POST (创建任务)
export async function POST(request: NextRequest) {
  try {
    const user = await getCurrentUser(request);
    const taskData = await request.json();
    
    // 验证权限
    await requireProjectPermission(PERMISSIONS.TASK_CREATE)(request);
    
    // 使用AI优化任务数据
    const aiOptimizer = new TaskAIOptimizer();
    const optimizedTask = await aiOptimizer.optimizeTaskCreation(taskData, user.id);
    
    // 创建任务
    const task = await prisma.task.create({
      data: {
        ...optimizedTask,
        createdBy: user.id,
        projectId: taskData.projectId
      },
      include: {
        assignee: true,
        creator: true,
        project: true,
        subtasks: true,
        dependencies: true
      }
    });
    
    // 触发工作流
    await triggerTaskWorkflow(task.id, 'CREATED');
    
    // 发送实时更新
    await broadcastTaskUpdate(task.projectId, 'task_created', task);
    
    return NextResponse.json(task);
  } catch (error) {
    return APIErrorHandler.handleTaskError(error, 'create_task');
  }
}

// /api/tasks/[id] - PATCH (更新任务)
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const user = await getCurrentUser(request);
    const updates = await request.json();
    const taskId = params.id;
    
    // 获取现有任务
    const existingTask = await prisma.task.findUnique({
      where: { id: taskId },
      include: { project: true }
    });
    
    if (!existingTask) {
      return NextResponse.json({ error: 'Task not found' }, { status: 404 });
    }
    
    // 验证权限
    await requireTaskPermission(taskId, PERMISSIONS.TASK_UPDATE)(request);
    
    // AI辅助更新验证
    const aiValidator = new TaskUpdateValidator();
    const validationResult = await aiValidator.validateUpdate(
      existingTask,
      updates,
      user.id
    );
    
    if (!validationResult.isValid) {
      return NextResponse.json(
        { error: validationResult.reason },
        { status: 400 }
      );
    }
    
    // 更新任务
    const updatedTask = await prisma.task.update({
      where: { id: taskId },
      data: {
        ...updates,
        updatedAt: new Date()
      },
      include: {
        assignee: true,
        creator: true,
        project: true,
        subtasks: true,
        dependencies: true
      }
    });
    
    // 触发工作流
    if (updates.status && updates.status !== existingTask.status) {
      await triggerTaskWorkflow(taskId, 'STATUS_CHANGED', {
        oldStatus: existingTask.status,
        newStatus: updates.status
      });
    }
    
    // 发送实时更新
    await broadcastTaskUpdate(
      existingTask.projectId,
      'task_updated',
      { taskId, updates }
    );
    
    return NextResponse.json(updatedTask);
  } catch (error) {
    return APIErrorHandler.handleTaskError(error, 'update_task');
  }
}
```

#### 4.1.2 AI任务建议接口
```typescript
// /api/ai/tasks/suggestions - POST
export async function POST(request: NextRequest) {
  try {
    const user = await getCurrentUser(request);
    const { projectId, context, tasks } = await request.json();
    
    await requireAIPermission(AI_PERMISSIONS.TASK_AI_SUGGESTIONS)(request);
    
    // 使用LangGraph工作流生成建议
    const suggestionAgent = new TaskSuggestionAgent();
    const suggestions = await suggestionAgent.generateSuggestions({
      projectId,
      context,
      currentTasks: tasks,
      userId: user.id
    });
    
    return NextResponse.json(suggestions);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to generate suggestions' },
      { status: 500 }
    );
  }
}

// /api/ai/tasks/generate - POST
export async function POST(request: NextRequest) {
  try {
    const user = await getCurrentUser(request);
    const { projectId, description, context } = await request.json();
    
    await requireAIPermission(AI_PERMISSIONS.TASK_AI_GENERATION)(request);
    
    // 使用LangChain生成任务
    const taskGenerator = new AITaskGenerator();
    const generatedTasks = await taskGenerator.generateFromDescription({
      description,
      projectId,
      context,
      userId: user.id
    });
    
    return NextResponse.json({ suggestions: generatedTasks });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to generate tasks' },
      { status: 500 }
    );
  }
}
```

### 4.2 LangChain任务优化器

#### 4.2.1 任务AI优化器
```typescript
// lib/ai/task-ai-optimizer.ts
import { LLMChain } from 'langchain/chains';
import { ChatOpenAI } from 'langchain/chat_models/openai';
import { PromptTemplate } from 'langchain/prompts';

export class TaskAIOptimizer {
  private llm: ChatOpenAI;
  private optimizationChain: LLMChain;
  
  constructor() {
    this.llm = new ChatOpenAI({
      modelName: 'gpt-4',
      temperature: 0.3
    });
    
    this.optimizationChain = this.createOptimizationChain();
  }
  
  private createOptimizationChain(): LLMChain {
    const prompt = PromptTemplate.fromTemplate(`
      优化以下任务信息，使其更加清晰、可执行和符合最佳实践：
      
      原始任务信息：
      标题：{title}
      描述：{description}
      优先级：{priority}
      预估工时：{estimatedHours}
      
      项目上下文：{projectContext}
      团队信息：{teamInfo}
      
      请优化并返回JSON格式的结果，包含：
      1. 优化后的标题（简洁明确）
      2. 详细的描述（包含验收标准）
      3. 合理的优先级（HIGH/MEDIUM/LOW）
      4. 准确的工时估算
      5. 建议的标签
      6. 推荐的负责人（基于技能匹配）
      7. 建议的子任务分解
      8. 相关依赖任务
      
      优化原则：
      - 任务应该是SMART（具体、可衡量、可达成、相关、有时限）
      - 描述应包含明确的验收标准
      - 工时估算应考虑复杂度和团队经验
      - 优先级应基于业务价值和紧急程度
    `);
    
    return new LLMChain({
      llm: this.llm,
      prompt
    });
  }
  
  async optimizeTaskCreation(taskData: any, userId: string): Promise<any> {
    try {
      // 获取项目和团队上下文
      const projectContext = await this.getProjectContext(taskData.projectId);
      const teamInfo = await this.getTeamInfo(taskData.projectId);
      
      const result = await this.optimizationChain.call({
        title: taskData.title || '',
        description: taskData.description || '',
        priority: taskData.priority || 'MEDIUM',
        estimatedHours: taskData.estimatedHours || 0,
        projectContext: JSON.stringify(projectContext),
        teamInfo: JSON.stringify(teamInfo)
      });
      
      const optimized = JSON.parse(result.text);
      
      return {
        title: optimized.title || taskData.title,
        description: optimized.description || taskData.description,
        priority: optimized.priority || taskData.priority,
        estimatedHours: optimized.estimatedHours || taskData.estimatedHours,
        tags: optimized.tags || [],
        assigneeId: optimized.recommendedAssignee || taskData.assigneeId,
        // 保留原始数据中的其他字段
        ...taskData,
        // AI优化的元数据
        aiOptimized: true,
        aiSuggestions: {
          subtasks: optimized.subtasks || [],
          dependencies: optimized.dependencies || []
        }
      };
    } catch (error) {
      console.error('任务优化失败:', error);
      // 如果AI优化失败，返回原始数据
      return taskData;
    }
  }
  
  private async getProjectContext(projectId: string) {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      include: {
        tasks: {
          select: {
            id: true,
            title: true,
            status: true,
            priority: true,
            tags: true
          },
          take: 20,
          orderBy: { createdAt: 'desc' }
        }
      }
    });
    
    return {
      name: project?.name,
      description: project?.description,
      recentTasks: project?.tasks || [],
      phase: project?.phase || 'PLANNING'
    };
  }
  
  private async getTeamInfo(projectId: string) {
    const members = await prisma.projectMember.findMany({
      where: { projectId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            skills: true,
            workload: true
          }
        }
      }
    });
    
    return members.map(member => ({
      id: member.user.id,
      name: member.user.name,
      role: member.role,
      skills: member.user.skills || [],
      currentWorkload: member.user.workload || 0
    }));
  }
}
```

#### 4.2.2 AI任务生成器
```typescript
// lib/ai/ai-task-generator.ts
export class AITaskGenerator {
  private llm: ChatOpenAI;
  private generationChain: LLMChain;
  
  constructor() {
    this.llm = new ChatOpenAI({
      modelName: 'gpt-4',
      temperature: 0.4
    });
    
    this.generationChain = this.createGenerationChain();
  }
  
  private createGenerationChain(): LLMChain {
    const prompt = PromptTemplate.fromTemplate(`
      基于以下描述，生成详细的任务列表：
      
      需求描述：{description}
      项目类型：{projectType}
      团队规模：{teamSize}
      技术栈：{techStack}
      
      请生成3-5个具体的任务，每个任务包含：
      1. 清晰的标题
      2. 详细的描述和验收标准
      3. 优先级（HIGH/MEDIUM/LOW）
      4. 预估工时（小时）
      5. 所需技能
      6. 建议的子任务
      7. 相关标签
      
      返回JSON数组格式，确保任务之间有逻辑顺序和依赖关系。
      
      示例格式：
      [
        {
          "title": "设计用户登录界面",
          "description": "创建响应式的用户登录页面，包含用户名/邮箱和密码输入框，以及记住我选项。验收标准：1. 支持移动端适配 2. 表单验证完整 3. 错误提示友好",
          "priority": "HIGH",
          "estimatedHours": 8,
          "requiredSkills": ["React", "CSS", "UI/UX"],
          "subtasks": ["设计原型", "编写组件", "添加验证", "测试适配"],
          "tags": ["前端", "UI", "登录"]
        }
      ]
    `);
    
    return new LLMChain({
      llm: this.llm,
      prompt
    });
  }
  
  async generateFromDescription(params: {
    description: string;
    projectId: string;
    context: string;
    userId: string;
  }): Promise<any[]> {
    try {
      // 获取项目信息
      const project = await prisma.project.findUnique({
        where: { id: params.projectId },
        include: {
          members: {
            include: {
              user: {
                select: { skills: true }
              }
            }
          }
        }
      });
      
      if (!project) {
        throw new Error('Project not found');
      }
      
      // 提取团队技能
      const teamSkills = project.members.flatMap(
        member => member.user.skills || []
      );
      
      const result = await this.generationChain.call({
        description: params.description,
        projectType: project.type || 'WEB_APPLICATION',
        teamSize: project.members.length,
        techStack: teamSkills.join(', ')
      });
      
      const tasks = JSON.parse(result.text);
      
      // 为每个任务添加推荐的负责人
      const tasksWithAssignees = await Promise.all(
        tasks.map(async (task: any) => {
          const recommendedAssignee = await this.findBestAssignee(
            task.requiredSkills || [],
            project.members
          );
          
          return {
            ...task,
            recommendedAssignee: recommendedAssignee?.userId,
            projectId: params.projectId
          };
        })
      );
      
      return tasksWithAssignees;
    } catch (error) {
      console.error('任务生成失败:', error);
      throw new Error('Failed to generate tasks');
    }
  }
  
  private async findBestAssignee(
    requiredSkills: string[],
    teamMembers: any[]
  ): Promise<{ userId: string; score: number } | null> {
    if (requiredSkills.length === 0 || teamMembers.length === 0) {
      return null;
    }
    
    const scores = teamMembers.map(member => {
      const memberSkills = member.user.skills || [];
      const matchingSkills = requiredSkills.filter(skill => 
        memberSkills.some((ms: string) => 
          ms.toLowerCase().includes(skill.toLowerCase())
        )
      );
      
      const skillScore = matchingSkills.length / requiredSkills.length;
      const workloadPenalty = (member.user.workload || 0) / 100; // 工作负载惩罚
      
      return {
        userId: member.userId,
        score: skillScore - workloadPenalty
      };
    });
    
    return scores.reduce((best, current) => 
      current.score > best.score ? current : best
    );
  }
}
```

### 4.3 LangGraph工作流引擎

#### 4.3.1 任务工作流定义
```typescript
// lib/ai/task-workflow.ts
import { StateGraph, END } from '@langchain/langgraph';
import { BaseMessage } from '@langchain/core/messages';

export interface TaskWorkflowState {
  taskId: string;
  action: string;
  context: Record<string, any>;
  result?: any;
  error?: string;
}

export class TaskWorkflowEngine {
  private graph: StateGraph<TaskWorkflowState>;
  
  constructor() {
    this.graph = this.createWorkflowGraph();
  }
  
  private createWorkflowGraph(): StateGraph<TaskWorkflowState> {
    const workflow = new StateGraph<TaskWorkflowState>({
      channels: {
        taskId: { value: null },
        action: { value: null },
        context: { value: {} },
        result: { value: null },
        error: { value: null }
      }
    });
    
    // 添加节点
    workflow.addNode('validate_task', this.validateTask.bind(this));
    workflow.addNode('analyze_dependencies', this.analyzeDependencies.bind(this));
    workflow.addNode('suggest_assignee', this.suggestAssignee.bind(this));
    workflow.addNode('estimate_effort', this.estimateEffort.bind(this));
    workflow.addNode('create_subtasks', this.createSubtasks.bind(this));
    workflow.addNode('notify_stakeholders', this.notifyStakeholders.bind(this));
    workflow.addNode('update_metrics', this.updateMetrics.bind(this));
    
    // 定义工作流路径
    workflow.addEdge('__start__', 'validate_task');
    workflow.addConditionalEdges(
      'validate_task',
      this.shouldContinue.bind(this),
      {
        'continue': 'analyze_dependencies',
        'error': END
      }
    );
    workflow.addEdge('analyze_dependencies', 'suggest_assignee');
    workflow.addEdge('suggest_assignee', 'estimate_effort');
    workflow.addEdge('estimate_effort', 'create_subtasks');
    workflow.addEdge('create_subtasks', 'notify_stakeholders');
    workflow.addEdge('notify_stakeholders', 'update_metrics');
    workflow.addEdge('update_metrics', END);
    
    return workflow.compile();
  }
  
  async executeWorkflow(taskId: string, action: string, context: any = {}) {
    const initialState: TaskWorkflowState = {
      taskId,
      action,
      context
    };
    
    try {
      const result = await this.graph.invoke(initialState);
      return result;
    } catch (error) {
      console.error('工作流执行失败:', error);
      throw error;
    }
  }
  
  private async validateTask(state: TaskWorkflowState): Promise<TaskWorkflowState> {
    try {
      const task = await prisma.task.findUnique({
        where: { id: state.taskId },
        include: { project: true }
      });
      
      if (!task) {
        return { ...state, error: 'Task not found' };
      }
      
      // 验证任务数据完整性
      const validation = this.validateTaskData(task);
      if (!validation.isValid) {
        return { ...state, error: validation.error };
      }
      
      return {
        ...state,
        context: { ...state.context, task, project: task.project }
      };
    } catch (error) {
      return { ...state, error: `Validation failed: ${error.message}` };
    }
  }
  
  private async analyzeDependencies(state: TaskWorkflowState): Promise<TaskWorkflowState> {
    try {
      const { task } = state.context;
      
      // 分析任务依赖关系
      const dependencies = await this.findTaskDependencies(task);
      const blockers = dependencies.filter(dep => dep.status !== 'DONE');
      
      // 检查循环依赖
      const hasCyclicDependency = await this.checkCyclicDependency(task.id, dependencies);
      
      return {
        ...state,
        context: {
          ...state.context,
          dependencies,
          blockers,
          hasCyclicDependency
        }
      };
    } catch (error) {
      return { ...state, error: `Dependency analysis failed: ${error.message}` };
    }
  }
  
  private async suggestAssignee(state: TaskWorkflowState): Promise<TaskWorkflowState> {
    try {
      const { task, project } = state.context;
      
      // 使用AI分析最佳负责人
      const assigneeSuggestion = await this.analyzeOptimalAssignee(task, project);
      
      return {
        ...state,
        context: {
          ...state.context,
          suggestedAssignee: assigneeSuggestion
        }
      };
    } catch (error) {
      return { ...state, error: `Assignee suggestion failed: ${error.message}` };
    }
  }
  
  private async estimateEffort(state: TaskWorkflowState): Promise<TaskWorkflowState> {
    try {
      const { task, project } = state.context;
      
      // AI驱动的工时估算
      const effortEstimation = await this.estimateTaskEffort(task, project);
      
      return {
        ...state,
        context: {
          ...state.context,
          effortEstimation
        }
      };
    } catch (error) {
      return { ...state, error: `Effort estimation failed: ${error.message}` };
    }
  }
  
  private async createSubtasks(state: TaskWorkflowState): Promise<TaskWorkflowState> {
    try {
      const { task } = state.context;
      
      // 如果任务复杂度高，自动生成子任务建议
      if (task.complexity === 'HIGH' || task.estimatedHours > 16) {
        const subtaskSuggestions = await this.generateSubtaskSuggestions(task);
        
        return {
          ...state,
          context: {
            ...state.context,
            subtaskSuggestions
          }
        };
      }
      
      return state;
    } catch (error) {
      return { ...state, error: `Subtask creation failed: ${error.message}` };
    }
  }
  
  private async notifyStakeholders(state: TaskWorkflowState): Promise<TaskWorkflowState> {
    try {
      const { task, project, suggestedAssignee } = state.context;
      
      // 发送通知给相关人员
      const notifications = [];
      
      if (suggestedAssignee && task.assigneeId !== suggestedAssignee.id) {
        notifications.push({
          type: 'ASSIGNEE_SUGGESTION',
          userId: project.managerId,
          message: `AI建议将任务 "${task.title}" 分配给 ${suggestedAssignee.name}`
        });
      }
      
      if (state.context.blockers?.length > 0) {
        notifications.push({
          type: 'DEPENDENCY_BLOCKER',
          userId: task.assigneeId || project.managerId,
          message: `任务 "${task.title}" 被 ${state.context.blockers.length} 个依赖任务阻塞`
        });
      }
      
      // 发送通知
      await Promise.all(
        notifications.map(notification => this.sendNotification(notification))
      );
      
      return {
        ...state,
        context: {
          ...state.context,
          notificationsSent: notifications.length
        }
      };
    } catch (error) {
      return { ...state, error: `Notification failed: ${error.message}` };
    }
  }
  
  private async updateMetrics(state: TaskWorkflowState): Promise<TaskWorkflowState> {
    try {
      const { task, project } = state.context;
      
      // 更新项目指标
      await this.updateProjectMetrics(project.id, {
        taskCreated: state.action === 'CREATED',
        taskCompleted: state.action === 'STATUS_CHANGED' && task.status === 'DONE',
        aiOptimizationUsed: true
      });
      
      return {
        ...state,
        result: 'Workflow completed successfully'
      };
    } catch (error) {
      return { ...state, error: `Metrics update failed: ${error.message}` };
    }
  }
  
  private shouldContinue(state: TaskWorkflowState): string {
    return state.error ? 'error' : 'continue';
  }
  
  // 辅助方法
  private validateTaskData(task: any): { isValid: boolean; error?: string } {
    if (!task.title || task.title.trim().length === 0) {
      return { isValid: false, error: 'Task title is required' };
    }
    
    if (!task.projectId) {
      return { isValid: false, error: 'Project ID is required' };
    }
    
    return { isValid: true };
  }
  
  private async findTaskDependencies(task: any) {
    return await prisma.task.findMany({
      where: {
        id: { in: task.dependencyIds || [] }
      },
      select: {
        id: true,
        title: true,
        status: true,
        priority: true
      }
    });
  }
  
  private async checkCyclicDependency(taskId: string, dependencies: any[]): Promise<boolean> {
    // 实现循环依赖检测逻辑
    const visited = new Set<string>();
    const recursionStack = new Set<string>();
    
    const hasCycle = async (currentTaskId: string): Promise<boolean> => {
      if (recursionStack.has(currentTaskId)) {
        return true; // 发现循环
      }
      
      if (visited.has(currentTaskId)) {
        return false;
      }
      
      visited.add(currentTaskId);
      recursionStack.add(currentTaskId);
      
      const taskDeps = await prisma.task.findUnique({
        where: { id: currentTaskId },
        select: { dependencyIds: true }
      });
      
      if (taskDeps?.dependencyIds) {
        for (const depId of taskDeps.dependencyIds) {
          if (await hasCycle(depId)) {
            return true;
          }
        }
      }
      
      recursionStack.delete(currentTaskId);
      return false;
    };
    
    return await hasCycle(taskId);
  }
  
  private async analyzeOptimalAssignee(task: any, project: any) {
    // 实现AI驱动的负责人分析
    const teamMembers = await prisma.projectMember.findMany({
      where: { projectId: project.id },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            skills: true,
            workload: true,
            performance: true
          }
        }
      }
    });
    
    // 使用简单的评分算法（实际应用中可以使用更复杂的AI模型）
    const scores = teamMembers.map(member => {
      const skillMatch = this.calculateSkillMatch(task.requiredSkills || [], member.user.skills || []);
      const workloadScore = Math.max(0, 1 - (member.user.workload || 0) / 100);
      const performanceScore = (member.user.performance || 0.5);
      
      return {
        ...member.user,
        score: skillMatch * 0.5 + workloadScore * 0.3 + performanceScore * 0.2
      };
    });
    
    return scores.reduce((best, current) => 
      current.score > best.score ? current : best
    );
  }
  
  private calculateSkillMatch(requiredSkills: string[], userSkills: string[]): number {
    if (requiredSkills.length === 0) return 0.5;
    
    const matches = requiredSkills.filter(skill => 
      userSkills.some(userSkill => 
        userSkill.toLowerCase().includes(skill.toLowerCase())
      )
    );
    
    return matches.length / requiredSkills.length;
  }
  
  private async estimateTaskEffort(task: any, project: any) {
    // AI驱动的工时估算（简化版本）
    const baseHours = task.estimatedHours || 8;
    const complexityMultiplier = {
      'LOW': 0.8,
      'MEDIUM': 1.0,
      'HIGH': 1.5,
      'VERY_HIGH': 2.0
    }[task.complexity || 'MEDIUM'];
    
    const teamExperienceMultiplier = project.teamExperience || 1.0;
    
    return {
      originalEstimate: baseHours,
      adjustedEstimate: Math.round(baseHours * complexityMultiplier * teamExperienceMultiplier),
      confidence: 0.75,
      factors: {
        complexity: task.complexity,
        teamExperience: project.teamExperience
      }
    };
  }
  
  private async generateSubtaskSuggestions(task: any) {
    // 基于任务类型和描述生成子任务建议
    const suggestions = [];
    
    if (task.type === 'FEATURE') {
      suggestions.push(
        { title: '需求分析和设计', estimatedHours: 4 },
        { title: '前端实现', estimatedHours: 8 },
        { title: '后端API开发', estimatedHours: 6 },
        { title: '测试和调试', estimatedHours: 4 },
        { title: '代码审查和部署', estimatedHours: 2 }
      );
    } else if (task.type === 'BUG') {
      suggestions.push(
        { title: '问题复现和分析', estimatedHours: 2 },
        { title: '修复实现', estimatedHours: 4 },
        { title: '测试验证', estimatedHours: 2 }
      );
    }
    
    return suggestions;
  }
  
  private async sendNotification(notification: any) {
    // 实现通知发送逻辑
    await prisma.notification.create({
      data: {
        userId: notification.userId,
        type: notification.type,
        message: notification.message,
        createdAt: new Date()
      }
    });
  }
  
  private async updateProjectMetrics(projectId: string, metrics: any) {
    // 更新项目指标
    await prisma.projectMetrics.upsert({
      where: { projectId },
      update: {
        tasksCreated: metrics.taskCreated ? { increment: 1 } : undefined,
        tasksCompleted: metrics.taskCompleted ? { increment: 1 } : undefined,
        aiOptimizationsUsed: metrics.aiOptimizationUsed ? { increment: 1 } : undefined,
        updatedAt: new Date()
      },
      create: {
        projectId,
        tasksCreated: metrics.taskCreated ? 1 : 0,
        tasksCompleted: metrics.taskCompleted ? 1 : 0,
        aiOptimizationsUsed: metrics.aiOptimizationUsed ? 1 : 0
      }
    });
  }
}

// 工作流触发器
export async function triggerTaskWorkflow(
  taskId: string, 
  action: string, 
  context: any = {}
) {
  const workflowEngine = new TaskWorkflowEngine();
  return await workflowEngine.executeWorkflow(taskId, action, context);
}
```

## 5. 数据库设计

### 5.1 数据表结构

#### 5.1.1 任务相关表
```sql
-- 任务表
CREATE TABLE tasks (
  id VARCHAR(36) PRIMARY KEY,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  status ENUM('TODO', 'IN_PROGRESS', 'REVIEW', 'DONE', 'BLOCKED') DEFAULT 'TODO',
  priority ENUM('LOW', 'MEDIUM', 'HIGH', 'URGENT') DEFAULT 'MEDIUM',
  type ENUM('FEATURE', 'BUG', 'IMPROVEMENT', 'RESEARCH') DEFAULT 'FEATURE',
  complexity ENUM('LOW', 'MEDIUM', 'HIGH', 'VERY_HIGH') DEFAULT 'MEDIUM',
  
  -- 时间相关
  estimated_hours DECIMAL(5,2),
  actual_hours DECIMAL(5,2),
  start_date DATETIME,
  due_date DATETIME,
  completed_at DATETIME,
  
  -- 关联关系
  project_id VARCHAR(36) NOT NULL,
  assignee_id VARCHAR(36),
  creator_id VARCHAR(36) NOT NULL,
  parent_task_id VARCHAR(36), -- 父任务ID（用于子任务）
  
  -- 进度和评估
  progress TINYINT DEFAULT 0, -- 0-100
  story_points TINYINT,
  
  -- AI相关
  ai_optimized BOOLEAN DEFAULT FALSE,
  ai_suggestions JSON,
  
  -- 元数据
  tags JSON, -- 存储标签数组
  custom_fields JSON, -- 自定义字段
  
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  INDEX idx_project_status (project_id, status),
  INDEX idx_assignee_status (assignee_id, status),
  INDEX idx_due_date (due_date),
  INDEX idx_priority_status (priority, status),
  
  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
  FOREIGN KEY (assignee_id) REFERENCES users(id) ON DELETE SET NULL,
  FOREIGN KEY (creator_id) REFERENCES users(id) ON DELETE RESTRICT,
  FOREIGN KEY (parent_task_id) REFERENCES tasks(id) ON DELETE CASCADE
);

-- 任务依赖关系表
CREATE TABLE task_dependencies (
  id VARCHAR(36) PRIMARY KEY,
  task_id VARCHAR(36) NOT NULL,
  depends_on_task_id VARCHAR(36) NOT NULL,
  dependency_type ENUM('FINISH_TO_START', 'START_TO_START', 'FINISH_TO_FINISH') DEFAULT 'FINISH_TO_START',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  UNIQUE KEY unique_dependency (task_id, depends_on_task_id),
  INDEX idx_task_dependencies (task_id),
  INDEX idx_depends_on (depends_on_task_id),
  
  FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
  FOREIGN KEY (depends_on_task_id) REFERENCES tasks(id) ON DELETE CASCADE
);

-- 任务评论表
CREATE TABLE task_comments (
  id VARCHAR(36) PRIMARY KEY,
  task_id VARCHAR(36) NOT NULL,
  user_id VARCHAR(36) NOT NULL,
  content TEXT NOT NULL,
  comment_type ENUM('COMMENT', 'STATUS_CHANGE', 'ASSIGNMENT', 'AI_SUGGESTION') DEFAULT 'COMMENT',
  metadata JSON, -- 存储额外信息，如状态变更详情
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  INDEX idx_task_comments (task_id, created_at),
  INDEX idx_user_comments (user_id, created_at),
  
  FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- 任务时间记录表
CREATE TABLE task_time_logs (
  id VARCHAR(36) PRIMARY KEY,
  task_id VARCHAR(36) NOT NULL,
  user_id VARCHAR(36) NOT NULL,
  start_time DATETIME NOT NULL,
  end_time DATETIME,
  duration_minutes INT, -- 计算得出的时长（分钟）
  description TEXT,
  log_type ENUM('MANUAL', 'AUTOMATIC', 'AI_ESTIMATED') DEFAULT 'MANUAL',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  INDEX idx_task_time_logs (task_id, start_time),
  INDEX idx_user_time_logs (user_id, start_time),
  
  FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- 任务附件表
CREATE TABLE task_attachments (
  id VARCHAR(36) PRIMARY KEY,
  task_id VARCHAR(36) NOT NULL,
  user_id VARCHAR(36) NOT NULL,
  filename VARCHAR(255) NOT NULL,
  file_path VARCHAR(500) NOT NULL,
  file_size BIGINT,
  mime_type VARCHAR(100),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  INDEX idx_task_attachments (task_id),
  
  FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

#### 5.1.2 AI相关表
```sql
-- AI建议表
CREATE TABLE ai_suggestions (
  id VARCHAR(36) PRIMARY KEY,
  suggestion_type ENUM('TASK_OPTIMIZATION', 'ASSIGNEE_RECOMMENDATION', 'WORKFLOW_IMPROVEMENT', 'RISK_ALERT') NOT NULL,
  target_type ENUM('TASK', 'PROJECT', 'USER') NOT NULL,
  target_id VARCHAR(36) NOT NULL,
  
  -- 建议内容
  title VARCHAR(255) NOT NULL,
  description TEXT,
  confidence_score DECIMAL(3,2), -- 0.00-1.00
  priority ENUM('LOW', 'MEDIUM', 'HIGH') DEFAULT 'MEDIUM',
  
  -- 建议数据
  suggestion_data JSON, -- 存储具体的建议内容
  
  -- 状态
  status ENUM('PENDING', 'ACCEPTED', 'REJECTED', 'EXPIRED') DEFAULT 'PENDING',
  applied_at DATETIME,
  applied_by VARCHAR(36),
  
  -- AI模型信息
  model_version VARCHAR(50),
  generation_context JSON,
  
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  expires_at DATETIME,
  
  INDEX idx_target (target_type, target_id, status),
  INDEX idx_suggestion_type (suggestion_type, status),
  INDEX idx_created_at (created_at),
  
  FOREIGN KEY (applied_by) REFERENCES users(id) ON DELETE SET NULL
);

-- AI工作流执行记录表
CREATE TABLE ai_workflow_executions (
  id VARCHAR(36) PRIMARY KEY,
  workflow_name VARCHAR(100) NOT NULL,
  trigger_event VARCHAR(100) NOT NULL,
  target_id VARCHAR(36) NOT NULL,
  
  -- 执行状态
  status ENUM('RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED') DEFAULT 'RUNNING',
  start_time DATETIME NOT NULL,
  end_time DATETIME,
  duration_ms BIGINT,
  
  -- 执行数据
  input_data JSON,
  output_data JSON,
  error_message TEXT,
  
  -- 性能指标
  steps_completed INT DEFAULT 0,
  total_steps INT,
  
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  INDEX idx_workflow_status (workflow_name, status),
  INDEX idx_target_executions (target_id, start_time),
  INDEX idx_execution_time (start_time)
);
```

### 5.2 数据访问层

#### 5.2.1 任务数据访问对象
```typescript
// lib/db/task-dao.ts
export class TaskDAO {
  async createTask(taskData: CreateTaskInput): Promise<Task> {
    return await prisma.task.create({
      data: {
        ...taskData,
        id: generateId(),
        createdAt: new Date()
      },
      include: {
        assignee: true,
        creator: true,
        project: true,
        subtasks: true,
        dependencies: {
          include: {
            dependsOnTask: {
              select: {
                id: true,
                title: true,
                status: true
              }
            }
          }
        },
        comments: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                avatar: true
              }
            }
          },
          orderBy: { createdAt: 'desc' },
          take: 5
        }
      }
    });
  }
  
  async getTasksByProject(
    projectId: string,
    filters: TaskFilters = {},
    pagination: PaginationOptions = {}
  ): Promise<{ tasks: Task[]; total: number }> {
    const where: any = { projectId };
    
    // 应用过滤器
    if (filters.status?.length) {
      where.status = { in: filters.status };
    }
    
    if (filters.assigneeIds?.length) {
      where.assigneeId = { in: filters.assigneeIds };
    }
    
    if (filters.priority?.length) {
      where.priority = { in: filters.priority };
    }
    
    if (filters.tags?.length) {
      where.tags = {
        array_contains: filters.tags
      };
    }
    
    if (filters.dateRange?.start && filters.dateRange?.end) {
      where.dueDate = {
        gte: filters.dateRange.start,
        lte: filters.dateRange.end
      };
    }
    
    if (filters.search) {
      where.OR = [
        { title: { contains: filters.search, mode: 'insensitive' } },
        { description: { contains: filters.search, mode: 'insensitive' } }
      ];
    }
    
    const [tasks, total] = await Promise.all([
      prisma.task.findMany({
        where,
        include: {
          assignee: {
            select: {
              id: true,
              name: true,
              avatar: true
            }
          },
          creator: {
            select: {
              id: true,
              name: true
            }
          },
          subtasks: {
            select: {
              id: true,
              title: true,
              status: true
            }
          },
          dependencies: {
            include: {
              dependsOnTask: {
                select: {
                  id: true,
                  title: true,
                  status: true
                }
              }
            }
          },
          _count: {
            select: {
              comments: true,
              attachments: true
            }
          }
        },
        orderBy: [
          { priority: 'desc' },
          { createdAt: 'desc' }
        ],
        skip: pagination.offset || 0,
        take: pagination.limit || 50
      }),
      prisma.task.count({ where })
    ]);
    
    return { tasks, total };
  }
  
  async updateTask(
    taskId: string,
    updates: UpdateTaskInput,
    userId: string
  ): Promise<Task> {
    // 记录状态变更
    const existingTask = await prisma.task.findUnique({
      where: { id: taskId },
      select: { status: true, assigneeId: true }
    });
    
    const updatedTask = await prisma.task.update({
      where: { id: taskId },
      data: {
        ...updates,
        updatedAt: new Date()
      },
      include: {
        assignee: true,
        creator: true,
        project: true,
        subtasks: true,
        dependencies: {
          include: {
            dependsOnTask: {
              select: {
                id: true,
                title: true,
                status: true
              }
            }
          }
        }
      }
    });
    
    // 记录变更历史
    if (updates.status && updates.status !== existingTask?.status) {
      await this.createStatusChangeComment(
        taskId,
        userId,
        existingTask?.status,
        updates.status
      );
    }
    
    if (updates.assigneeId && updates.assigneeId !== existingTask?.assigneeId) {
      await this.createAssignmentComment(
        taskId,
        userId,
        existingTask?.assigneeId,
        updates.assigneeId
      );
    }
    
    return updatedTask;
  }
  
  async deleteTask(taskId: string): Promise<void> {
    // 检查是否有依赖此任务的其他任务
    const dependentTasks = await prisma.taskDependency.findMany({
      where: { dependsOnTaskId: taskId },
      include: {
        task: {
          select: {
            id: true,
            title: true
          }
        }
      }
    });
    
    if (dependentTasks.length > 0) {
      throw new Error(
        `无法删除任务，以下任务依赖于此任务: ${dependentTasks.map(d => d.task.title).join(', ')}`
      );
    }
    
    // 删除任务（级联删除相关数据）
    await prisma.task.delete({
      where: { id: taskId }
    });
  }
  
  async moveTask(
    taskId: string,
    newStatus: string,
    newIndex: number,
    userId: string
  ): Promise<Task> {
    // 在事务中更新任务状态和位置
    return await prisma.$transaction(async (tx) => {
      // 更新任务状态
      const updatedTask = await tx.task.update({
        where: { id: taskId },
        data: {
          status: newStatus as any,
          updatedAt: new Date()
        },
        include: {
          assignee: true,
          creator: true,
          project: true
        }
      });
      
      // 记录状态变更
      await tx.taskComment.create({
        data: {
          id: generateId(),
          taskId,
          userId,
          content: `任务状态变更为: ${newStatus}`,
          commentType: 'STATUS_CHANGE',
          metadata: {
            oldStatus: updatedTask.status,
            newStatus,
            newIndex
          }
        }
      });
      
      return updatedTask;
    });
  }
  
  async getTaskDependencies(taskId: string): Promise<TaskDependency[]> {
    return await prisma.taskDependency.findMany({
      where: { taskId },
      include: {
        dependsOnTask: {
          select: {
            id: true,
            title: true,
            status: true,
            priority: true,
            dueDate: true
          }
        }
      }
    });
  }
  
  async addTaskDependency(
    taskId: string,
    dependsOnTaskId: string,
    dependencyType: string = 'FINISH_TO_START'
  ): Promise<TaskDependency> {
    // 检查循环依赖
    const hasCycle = await this.checkCyclicDependency(taskId, dependsOnTaskId);
    if (hasCycle) {
      throw new Error('添加此依赖会创建循环依赖');
    }
    
    return await prisma.taskDependency.create({
      data: {
        id: generateId(),
        taskId,
        dependsOnTaskId,
        dependencyType: dependencyType as any
      },
      include: {
        dependsOnTask: {
          select: {
            id: true,
            title: true,
            status: true
          }
        }
      }
    });
  }
  
  private async createStatusChangeComment(
    taskId: string,
    userId: string,
    oldStatus?: string,
    newStatus?: string
  ): Promise<void> {
    await prisma.taskComment.create({
      data: {
        id: generateId(),
        taskId,
        userId,
        content: `任务状态从 "${oldStatus}" 变更为 "${newStatus}"`,
        commentType: 'STATUS_CHANGE',
        metadata: {
          oldStatus,
          newStatus,
          timestamp: new Date().toISOString()
        }
      }
    });
  }
  
  private async createAssignmentComment(
    taskId: string,
    userId: string,
    oldAssigneeId?: string,
    newAssigneeId?: string
  ): Promise<void> {
    const [oldAssignee, newAssignee] = await Promise.all([
      oldAssigneeId ? prisma.user.findUnique({
        where: { id: oldAssigneeId },
        select: { name: true }
      }) : null,
      newAssigneeId ? prisma.user.findUnique({
        where: { id: newAssigneeId },
        select: { name: true }
      }) : null
    ]);
    
    const content = newAssigneeId
      ? `任务分配给 ${newAssignee?.name || '未知用户'}`
      : '取消任务分配';
    
    await prisma.taskComment.create({
      data: {
        id: generateId(),
        taskId,
        userId,
        content,
        commentType: 'ASSIGNMENT',
        metadata: {
          oldAssigneeId,
          newAssigneeId,
          oldAssigneeName: oldAssignee?.name,
          newAssigneeName: newAssignee?.name
        }
      }
    });
  }
  
  private async checkCyclicDependency(
    taskId: string,
    dependsOnTaskId: string
  ): Promise<boolean> {
    // 使用深度优先搜索检测循环依赖
    const visited = new Set<string>();
    const recursionStack = new Set<string>();
    
    const hasCycle = async (currentTaskId: string): Promise<boolean> => {
      if (recursionStack.has(currentTaskId)) {
        return true;
      }
      
      if (visited.has(currentTaskId)) {
        return false;
      }
      
      visited.add(currentTaskId);
      recursionStack.add(currentTaskId);
      
      const dependencies = await prisma.taskDependency.findMany({
        where: { taskId: currentTaskId },
        select: { dependsOnTaskId: true }
      });
      
      for (const dep of dependencies) {
        if (await hasCycle(dep.dependsOnTaskId)) {
          return true;
        }
      }
      
      recursionStack.delete(currentTaskId);
      return false;
    };
    
    // 临时添加依赖关系进行检测
    return await hasCycle(dependsOnTaskId);
  }
}

// 类型定义
interface CreateTaskInput {
  title: string;
  description?: string;
  status?: string;
  priority?: string;
  type?: string;
  complexity?: string;
  estimatedHours?: number;
  dueDate?: Date;
  projectId: string;
  assigneeId?: string;
  creatorId: string;
  parentTaskId?: string;
  tags?: string[];
  customFields?: any;
}

interface UpdateTaskInput {
  title?: string;
  description?: string;
  status?: string;
  priority?: string;
  complexity?: string;
  estimatedHours?: number;
  actualHours?: number;
  dueDate?: Date;
  assigneeId?: string;
  progress?: number;
  storyPoints?: number;
  tags?: string[];
  customFields?: any;
}

interface TaskFilters {
  status?: string[];
  assigneeIds?: string[];
  priority?: string[];
  tags?: string[];
  dateRange?: {
    start: Date;
    end: Date;
  };
  search?: string;
}

interface PaginationOptions {
   offset?: number;
   limit?: number;
 }
 ```

## 6. 性能优化

### 6.1 前端性能优化

#### 6.1.1 虚拟化和懒加载
```typescript
// components/VirtualizedTaskList.tsx
import { FixedSizeList as List } from 'react-window';
import { memo, useMemo } from 'react';

interface VirtualizedTaskListProps {
  tasks: Task[];
  height: number;
  itemHeight: number;
  onTaskUpdate: (taskId: string, updates: Partial<Task>) => void;
}

const VirtualizedTaskList: React.FC<VirtualizedTaskListProps> = memo(({
  tasks,
  height,
  itemHeight,
  onTaskUpdate
}) => {
  const TaskItem = memo(({ index, style }: { index: number; style: any }) => {
    const task = tasks[index];
    
    return (
      <div style={style}>
        <SmartTaskCard
          task={task}
          onUpdate={onTaskUpdate}
          onAssign={(taskId, assigneeId) => {
            onTaskUpdate(taskId, { assigneeId });
          }}
        />
      </div>
    );
  });
  
  return (
    <List
      height={height}
      itemCount={tasks.length}
      itemSize={itemHeight}
      overscanCount={5}
    >
      {TaskItem}
    </List>
  );
});

// 懒加载任务数据
const useLazyTasks = (projectId: string) => {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const [page, setPage] = useState(0);
  
  const loadMoreTasks = useCallback(async () => {
    if (loading || !hasMore) return;
    
    setLoading(true);
    try {
      const response = await fetch(
        `/api/projects/${projectId}/tasks?page=${page}&limit=20`
      );
      const newTasks = await response.json();
      
      if (newTasks.length === 0) {
        setHasMore(false);
      } else {
        setTasks(prev => [...prev, ...newTasks]);
        setPage(prev => prev + 1);
      }
    } catch (error) {
      console.error('加载任务失败:', error);
    } finally {
      setLoading(false);
    }
  }, [projectId, page, loading, hasMore]);
  
  useEffect(() => {
    loadMoreTasks();
  }, []);
  
  return { tasks, loading, hasMore, loadMoreTasks };
};
```

#### 6.1.2 状态管理优化
```typescript
// hooks/useOptimizedTaskStore.ts
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

interface OptimizedTaskState {
  tasks: Map<string, Task>;
  tasksByProject: Map<string, string[]>;
  tasksByStatus: Map<string, string[]>;
  selectedTasks: Set<string>;
  filters: TaskFilters;
  loading: boolean;
}

interface OptimizedTaskActions {
  addTask: (task: Task) => void;
  updateTask: (taskId: string, updates: Partial<Task>) => void;
  removeTask: (taskId: string) => void;
  setTasks: (tasks: Task[]) => void;
  selectTask: (taskId: string) => void;
  deselectTask: (taskId: string) => void;
  clearSelection: () => void;
  setFilters: (filters: Partial<TaskFilters>) => void;
}

export const useOptimizedTaskStore = create<OptimizedTaskState & OptimizedTaskActions>()
  subscribeWithSelector(
    immer((set, get) => ({
      tasks: new Map(),
      tasksByProject: new Map(),
      tasksByStatus: new Map(),
      selectedTasks: new Set(),
      filters: {
        status: [],
        assigneeIds: [],
        priority: [],
        tags: [],
        dateRange: { start: null, end: null }
      },
      loading: false,

      addTask: (task) => set((state) => {
        state.tasks.set(task.id, task);
        
        // 更新项目索引
        const projectTasks = state.tasksByProject.get(task.projectId) || [];
        projectTasks.push(task.id);
        state.tasksByProject.set(task.projectId, projectTasks);
        
        // 更新状态索引
        const statusTasks = state.tasksByStatus.get(task.status) || [];
        statusTasks.push(task.id);
        state.tasksByStatus.set(task.status, statusTasks);
      }),

      updateTask: (taskId, updates) => set((state) => {
        const existingTask = state.tasks.get(taskId);
        if (!existingTask) return;
        
        const updatedTask = { ...existingTask, ...updates };
        state.tasks.set(taskId, updatedTask);
        
        // 如果状态发生变化，更新状态索引
        if (updates.status && updates.status !== existingTask.status) {
          // 从旧状态中移除
          const oldStatusTasks = state.tasksByStatus.get(existingTask.status) || [];
          const filteredOldTasks = oldStatusTasks.filter(id => id !== taskId);
          state.tasksByStatus.set(existingTask.status, filteredOldTasks);
          
          // 添加到新状态
          const newStatusTasks = state.tasksByStatus.get(updates.status) || [];
          newStatusTasks.push(taskId);
          state.tasksByStatus.set(updates.status, newStatusTasks);
        }
      }),

      removeTask: (taskId) => set((state) => {
        const task = state.tasks.get(taskId);
        if (!task) return;
        
        state.tasks.delete(taskId);
        state.selectedTasks.delete(taskId);
        
        // 从项目索引中移除
        const projectTasks = state.tasksByProject.get(task.projectId) || [];
        const filteredProjectTasks = projectTasks.filter(id => id !== taskId);
        state.tasksByProject.set(task.projectId, filteredProjectTasks);
        
        // 从状态索引中移除
        const statusTasks = state.tasksByStatus.get(task.status) || [];
        const filteredStatusTasks = statusTasks.filter(id => id !== taskId);
        state.tasksByStatus.set(task.status, filteredStatusTasks);
      }),

      setTasks: (tasks) => set((state) => {
        state.tasks.clear();
        state.tasksByProject.clear();
        state.tasksByStatus.clear();
        
        tasks.forEach(task => {
          state.tasks.set(task.id, task);
          
          // 构建项目索引
          const projectTasks = state.tasksByProject.get(task.projectId) || [];
          projectTasks.push(task.id);
          state.tasksByProject.set(task.projectId, projectTasks);
          
          // 构建状态索引
          const statusTasks = state.tasksByStatus.get(task.status) || [];
          statusTasks.push(task.id);
          state.tasksByStatus.set(task.status, statusTasks);
        });
      }),

      selectTask: (taskId) => set((state) => {
        state.selectedTasks.add(taskId);
      }),

      deselectTask: (taskId) => set((state) => {
        state.selectedTasks.delete(taskId);
      }),

      clearSelection: () => set((state) => {
        state.selectedTasks.clear();
      }),

      setFilters: (filters) => set((state) => {
        state.filters = { ...state.filters, ...filters };
      })
    }))
  )
);

// 选择器优化
export const useTasksByProject = (projectId: string) => {
  return useOptimizedTaskStore(
    useCallback(
      (state) => {
        const taskIds = state.tasksByProject.get(projectId) || [];
        return taskIds.map(id => state.tasks.get(id)).filter(Boolean) as Task[];
      },
      [projectId]
    )
  );
};

export const useTasksByStatus = (status: string) => {
  return useOptimizedTaskStore(
    useCallback(
      (state) => {
        const taskIds = state.tasksByStatus.get(status) || [];
        return taskIds.map(id => state.tasks.get(id)).filter(Boolean) as Task[];
      },
      [status]
    )
  );
};
```

### 6.2 后端性能优化

#### 6.2.1 Redis缓存策略
```typescript
// lib/cache/task-cache.ts
import Redis from 'ioredis';

export class TaskCacheManager {
  private redis: Redis;
  private readonly TTL = {
    TASK_LIST: 300, // 5分钟
    TASK_DETAIL: 600, // 10分钟
    AI_SUGGESTIONS: 1800, // 30分钟
    PROJECT_STATS: 900 // 15分钟
  };
  
  constructor() {
    this.redis = new Redis(process.env.REDIS_URL!);
  }
  
  // 缓存任务列表
  async cacheTaskList(
    projectId: string,
    filters: TaskFilters,
    tasks: Task[]
  ): Promise<void> {
    const cacheKey = this.getTaskListCacheKey(projectId, filters);
    await this.redis.setex(
      cacheKey,
      this.TTL.TASK_LIST,
      JSON.stringify(tasks)
    );
  }
  
  async getTaskList(
    projectId: string,
    filters: TaskFilters
  ): Promise<Task[] | null> {
    const cacheKey = this.getTaskListCacheKey(projectId, filters);
    const cached = await this.redis.get(cacheKey);
    return cached ? JSON.parse(cached) : null;
  }
  
  // 缓存任务详情
  async cacheTask(task: Task): Promise<void> {
    const cacheKey = `task:${task.id}`;
    await this.redis.setex(
      cacheKey,
      this.TTL.TASK_DETAIL,
      JSON.stringify(task)
    );
  }
  
  async getTask(taskId: string): Promise<Task | null> {
    const cached = await this.redis.get(`task:${taskId}`);
    return cached ? JSON.parse(cached) : null;
  }
  
  // 缓存AI建议
  async cacheAISuggestions(
    contextKey: string,
    suggestions: any[]
  ): Promise<void> {
    const cacheKey = `ai_suggestions:${contextKey}`;
    await this.redis.setex(
      cacheKey,
      this.TTL.AI_SUGGESTIONS,
      JSON.stringify(suggestions)
    );
  }
  
  async getAISuggestions(contextKey: string): Promise<any[] | null> {
    const cached = await this.redis.get(`ai_suggestions:${contextKey}`);
    return cached ? JSON.parse(cached) : null;
  }
  
  // 缓存项目统计
  async cacheProjectStats(
    projectId: string,
    stats: any
  ): Promise<void> {
    const cacheKey = `project_stats:${projectId}`;
    await this.redis.setex(
      cacheKey,
      this.TTL.PROJECT_STATS,
      JSON.stringify(stats)
    );
  }
  
  async getProjectStats(projectId: string): Promise<any | null> {
    const cached = await this.redis.get(`project_stats:${projectId}`);
    return cached ? JSON.parse(cached) : null;
  }
  
  // 清除相关缓存
  async invalidateTaskCaches(taskId: string, projectId: string): Promise<void> {
    const patterns = [
      `task:${taskId}`,
      `task_list:${projectId}:*`,
      `project_stats:${projectId}`,
      `ai_suggestions:*${taskId}*`
    ];
    
    for (const pattern of patterns) {
      const keys = await this.redis.keys(pattern);
      if (keys.length > 0) {
        await this.redis.del(...keys);
      }
    }
  }
  
  private getTaskListCacheKey(
    projectId: string,
    filters: TaskFilters
  ): string {
    const filterHash = this.hashFilters(filters);
    return `task_list:${projectId}:${filterHash}`;
  }
  
  private hashFilters(filters: TaskFilters): string {
    const normalized = {
      status: filters.status?.sort() || [],
      assigneeIds: filters.assigneeIds?.sort() || [],
      priority: filters.priority?.sort() || [],
      tags: filters.tags?.sort() || [],
      dateRange: filters.dateRange || null,
      search: filters.search || ''
    };
    
    return Buffer.from(JSON.stringify(normalized)).toString('base64');
  }
}
```

#### 6.2.2 数据库查询优化
```typescript
// lib/db/optimized-task-queries.ts
export class OptimizedTaskQueries {
  // 批量获取任务（减少N+1查询）
  async getTasksWithRelations(
    taskIds: string[]
  ): Promise<Map<string, Task>> {
    const tasks = await prisma.task.findMany({
      where: { id: { in: taskIds } },
      include: {
        assignee: {
          select: {
            id: true,
            name: true,
            avatar: true
          }
        },
        creator: {
          select: {
            id: true,
            name: true
          }
        },
        project: {
          select: {
            id: true,
            name: true
          }
        },
        _count: {
          select: {
            comments: true,
            subtasks: true,
            dependencies: true
          }
        }
      }
    });
    
    return new Map(tasks.map(task => [task.id, task]));
  }
  
  // 分页查询优化
  async getTasksPaginated(
    projectId: string,
    filters: TaskFilters,
    pagination: PaginationOptions
  ): Promise<{ tasks: Task[]; total: number; hasMore: boolean }> {
    const where = this.buildWhereClause(projectId, filters);
    
    // 使用游标分页而不是偏移分页（更高效）
    const limit = pagination.limit || 20;
    const cursor = pagination.cursor;
    
    const [tasks, total] = await Promise.all([
      prisma.task.findMany({
        where,
        include: {
          assignee: {
            select: {
              id: true,
              name: true,
              avatar: true
            }
          },
          _count: {
            select: {
              comments: true,
              subtasks: true
            }
          }
        },
        orderBy: [
          { priority: 'desc' },
          { createdAt: 'desc' }
        ],
        take: limit + 1, // 多取一个用于判断是否还有更多
        ...(cursor && {
          cursor: { id: cursor },
          skip: 1
        })
      }),
      // 只在第一页计算总数
      !cursor ? prisma.task.count({ where }) : Promise.resolve(0)
    ]);
    
    const hasMore = tasks.length > limit;
    if (hasMore) {
      tasks.pop(); // 移除多取的那一个
    }
    
    return {
      tasks,
      total,
      hasMore
    };
  }
  
  // 聚合查询优化
  async getProjectTaskStats(projectId: string): Promise<any> {
    const stats = await prisma.task.groupBy({
      by: ['status', 'priority'],
      where: { projectId },
      _count: {
        id: true
      },
      _avg: {
        estimatedHours: true,
        actualHours: true,
        progress: true
      }
    });
    
    // 转换为更友好的格式
    const result = {
      byStatus: {} as Record<string, number>,
      byPriority: {} as Record<string, number>,
      averages: {
        estimatedHours: 0,
        actualHours: 0,
        progress: 0
      }
    };
    
    let totalTasks = 0;
    let totalEstimated = 0;
    let totalActual = 0;
    let totalProgress = 0;
    
    stats.forEach(stat => {
      const count = stat._count.id;
      totalTasks += count;
      
      result.byStatus[stat.status] = (result.byStatus[stat.status] || 0) + count;
      result.byPriority[stat.priority] = (result.byPriority[stat.priority] || 0) + count;
      
      if (stat._avg.estimatedHours) {
        totalEstimated += stat._avg.estimatedHours * count;
      }
      if (stat._avg.actualHours) {
        totalActual += stat._avg.actualHours * count;
      }
      if (stat._avg.progress) {
        totalProgress += stat._avg.progress * count;
      }
    });
    
    if (totalTasks > 0) {
      result.averages = {
        estimatedHours: totalEstimated / totalTasks,
        actualHours: totalActual / totalTasks,
        progress: totalProgress / totalTasks
      };
    }
    
    return result;
  }
  
  private buildWhereClause(projectId: string, filters: TaskFilters): any {
    const where: any = { projectId };
    
    if (filters.status?.length) {
      where.status = { in: filters.status };
    }
    
    if (filters.assigneeIds?.length) {
      where.assigneeId = { in: filters.assigneeIds };
    }
    
    if (filters.priority?.length) {
      where.priority = { in: filters.priority };
    }
    
    if (filters.tags?.length) {
      where.tags = {
        hasEvery: filters.tags
      };
    }
    
    if (filters.dateRange?.start && filters.dateRange?.end) {
      where.dueDate = {
        gte: filters.dateRange.start,
        lte: filters.dateRange.end
      };
    }
    
    if (filters.search) {
      where.OR = [
        {
          title: {
            contains: filters.search,
            mode: 'insensitive'
          }
        },
        {
          description: {
            contains: filters.search,
            mode: 'insensitive'
          }
        }
      ];
    }
    
    return where;
  }
}
```

## 7. 错误处理和监控

### 7.1 前端错误处理

#### 7.1.1 错误边界组件
```typescript
// components/TaskErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AlertTriangle, RefreshCw } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
  errorInfo?: ErrorInfo;
}

export class TaskErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error: Error): State {
    return {
      hasError: true,
      error
    };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    this.setState({
      error,
      errorInfo
    });
    
    // 发送错误报告
    this.reportError(error, errorInfo);
  }
  
  private reportError = (error: Error, errorInfo: ErrorInfo) => {
    // 发送到错误监控服务
    if (typeof window !== 'undefined') {
      fetch('/api/errors', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          message: error.message,
          stack: error.stack,
          componentStack: errorInfo.componentStack,
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          url: window.location.href
        })
      }).catch(console.error);
    }
  };
  
  private handleRetry = () => {
    this.setState({ hasError: false, error: undefined, errorInfo: undefined });
  };
  
  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }
      
      return (
        <div className="p-6 max-w-lg mx-auto">
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertTitle>任务管理出现错误</AlertTitle>
            <AlertDescription className="mt-2">
              <p className="mb-4">
                抱歉，任务管理功能遇到了问题。请尝试刷新页面或联系技术支持。
              </p>
              
              {process.env.NODE_ENV === 'development' && (
                <details className="mb-4">
                  <summary className="cursor-pointer font-medium">
                    错误详情（开发模式）
                  </summary>
                  <pre className="mt-2 text-xs bg-gray-100 p-2 rounded overflow-auto">
                    {this.state.error?.message}
                    {this.state.error?.stack}
                  </pre>
                </details>
              )}
              
              <div className="flex gap-2">
                <Button
                  onClick={this.handleRetry}
                  size="sm"
                  variant="outline"
                >
                  <RefreshCw className="w-4 h-4 mr-2" />
                  重试
                </Button>
                
                <Button
                  onClick={() => window.location.reload()}
                  size="sm"
                >
                  刷新页面
                </Button>
              </div>
            </AlertDescription>
          </Alert>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

#### 7.1.2 API错误处理
```typescript
// lib/api/error-handler.ts
export class APIError extends Error {
  constructor(
    message: string,
    public status: number,
    public code?: string,
    public details?: any
  ) {
    super(message);
    this.name = 'APIError';
  }
}

export class TaskAPIErrorHandler {
  static async handleResponse(response: Response): Promise<any> {
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      
      throw new APIError(
        errorData.message || this.getDefaultErrorMessage(response.status),
        response.status,
        errorData.code,
        errorData.details
      );
    }
    
    return response.json();
  }
  
  static handleError(error: unknown): string {
    if (error instanceof APIError) {
      switch (error.status) {
        case 400:
          return error.message || '请求参数错误';
        case 401:
          return '请先登录';
        case 403:
          return '没有权限执行此操作';
        case 404:
          return '任务不存在';
        case 409:
          return '操作冲突，请刷新后重试';
        case 429:
          return '操作过于频繁，请稍后重试';
        case 500:
          return '服务器内部错误';
        default:
          return error.message || '操作失败';
      }
    }
    
    if (error instanceof Error) {
      return error.message;
    }
    
    return '未知错误';
  }
  
  private static getDefaultErrorMessage(status: number): string {
    switch (status) {
      case 400: return '请求参数错误';
      case 401: return '未授权访问';
      case 403: return '禁止访问';
      case 404: return '资源不存在';
      case 409: return '资源冲突';
      case 429: return '请求过于频繁';
      case 500: return '服务器内部错误';
      case 502: return '网关错误';
      case 503: return '服务不可用';
      default: return '网络错误';
    }
  }
}

// 全局错误处理Hook
export const useErrorHandler = () => {
  const [error, setError] = useState<string | null>(null);
  
  const handleError = useCallback((error: unknown) => {
    const message = TaskAPIErrorHandler.handleError(error);
    setError(message);
    
    // 自动清除错误消息
    setTimeout(() => setError(null), 5000);
  }, []);
  
  const clearError = useCallback(() => {
    setError(null);
  }, []);
  
  return { error, handleError, clearError };
};
```

### 7.2 后端错误处理

#### 7.2.1 API错误处理中间件
```typescript
// lib/api/error-middleware.ts
import { NextRequest, NextResponse } from 'next/server';
import { ZodError } from 'zod';
import { Prisma } from '@prisma/client';

export class APIErrorHandler {
  static handleTaskError(error: unknown, context: string): NextResponse {
    console.error(`Task API Error [${context}]:`, error);
    
    // Zod验证错误
    if (error instanceof ZodError) {
      return NextResponse.json(
        {
          error: '请求参数验证失败',
          code: 'VALIDATION_ERROR',
          details: error.errors.map(e => ({
            field: e.path.join('.'),
            message: e.message
          }))
        },
        { status: 400 }
      );
    }
    
    // Prisma错误
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002':
          return NextResponse.json(
            {
              error: '数据已存在',
              code: 'DUPLICATE_ERROR',
              details: { field: error.meta?.target }
            },
            { status: 409 }
          );
        
        case 'P2025':
          return NextResponse.json(
            {
              error: '记录不存在',
              code: 'NOT_FOUND',
              details: { operation: error.meta?.cause }
            },
            { status: 404 }
          );
        
        case 'P2003':
          return NextResponse.json(
            {
              error: '外键约束失败',
              code: 'FOREIGN_KEY_ERROR',
              details: { field: error.meta?.field_name }
            },
            { status: 400 }
          );
        
        default:
          return NextResponse.json(
            {
              error: '数据库操作失败',
              code: 'DATABASE_ERROR',
              details: { code: error.code }
            },
            { status: 500 }
          );
      }
    }
    
    // 自定义业务错误
    if (error instanceof Error) {
      if (error.message.includes('权限')) {
        return NextResponse.json(
          {
            error: error.message,
            code: 'PERMISSION_DENIED'
          },
          { status: 403 }
        );
      }
      
      if (error.message.includes('不存在')) {
        return NextResponse.json(
          {
            error: error.message,
            code: 'NOT_FOUND'
          },
          { status: 404 }
        );
      }
      
      if (error.message.includes('循环依赖')) {
        return NextResponse.json(
          {
            error: error.message,
            code: 'CIRCULAR_DEPENDENCY'
          },
          { status: 400 }
        );
      }
    }
    
    // 默认服务器错误
    return NextResponse.json(
      {
        error: '服务器内部错误',
        code: 'INTERNAL_ERROR',
        requestId: this.generateRequestId()
      },
      { status: 500 }
    );
  }
  
  private static generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

// 错误监控
export class ErrorMonitor {
  static async logError(
    error: Error,
    context: {
      userId?: string;
      taskId?: string;
      projectId?: string;
      action?: string;
      request?: NextRequest;
    }
  ): Promise<void> {
    try {
      await prisma.errorLog.create({
        data: {
          id: generateId(),
          message: error.message,
          stack: error.stack,
          context: JSON.stringify(context),
          userAgent: context.request?.headers.get('user-agent'),
          ip: this.getClientIP(context.request),
          createdAt: new Date()
        }
      });
    } catch (logError) {
      console.error('Failed to log error:', logError);
    }
  }
  
  private static getClientIP(request?: NextRequest): string | null {
    if (!request) return null;
    
    return (
      request.headers.get('x-forwarded-for')?.split(',')[0] ||
      request.headers.get('x-real-ip') ||
      null
    );
  }
}
```

### 7.3 监控指标

#### 7.3.1 性能监控
```typescript
// lib/monitoring/performance-monitor.ts
export class TaskPerformanceMonitor {
  private static metrics = new Map<string, number[]>();
  
  static startTimer(operation: string): () => void {
    const startTime = performance.now();
    
    return () => {
      const duration = performance.now() - startTime;
      this.recordMetric(operation, duration);
    };
  }
  
  static recordMetric(operation: string, value: number): void {
    if (!this.metrics.has(operation)) {
      this.metrics.set(operation, []);
    }
    
    const values = this.metrics.get(operation)!;
    values.push(value);
    
    // 保持最近100个记录
    if (values.length > 100) {
      values.shift();
    }
  }
  
  static getMetrics(operation: string): {
    avg: number;
    min: number;
    max: number;
    p95: number;
    count: number;
  } | null {
    const values = this.metrics.get(operation);
    if (!values || values.length === 0) return null;
    
    const sorted = [...values].sort((a, b) => a - b);
    const sum = values.reduce((a, b) => a + b, 0);
    
    return {
      avg: sum / values.length,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      count: values.length
    };
  }
  
  static getAllMetrics(): Record<string, any> {
    const result: Record<string, any> = {};
    
    for (const [operation] of this.metrics) {
      result[operation] = this.getMetrics(operation);
    }
    
    return result;
  }
}

// 使用示例
const useTaskPerformance = () => {
  const measureTaskLoad = useCallback(async (projectId: string) => {
    const endTimer = TaskPerformanceMonitor.startTimer('task_load');
    
    try {
      const response = await fetch(`/api/projects/${projectId}/tasks`);
      const tasks = await response.json();
      return tasks;
    } finally {
      endTimer();
    }
  }, []);
  
  const measureTaskUpdate = useCallback(async (taskId: string, updates: any) => {
    const endTimer = TaskPerformanceMonitor.startTimer('task_update');
    
    try {
      const response = await fetch(`/api/tasks/${taskId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });
      return await response.json();
    } finally {
      endTimer();
    }
  }, []);
  
  return { measureTaskLoad, measureTaskUpdate };
};
```

## 8. 测试策略

### 8.1 单元测试

#### 8.1.1 组件测试
```typescript
// __tests__/components/SmartTaskCard.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { SmartTaskCard } from '@/components/SmartTaskCard';
import { mockTask } from '../__mocks__/task-data';

describe('SmartTaskCard', () => {
  const mockOnUpdate = jest.fn();
  const mockOnAssign = jest.fn();
  
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  it('应该正确渲染任务信息', () => {
    render(
      <SmartTaskCard
        task={mockTask}
        onUpdate={mockOnUpdate}
        onAssign={mockOnAssign}
      />
    );
    
    expect(screen.getByText(mockTask.title)).toBeInTheDocument();
    expect(screen.getByText(mockTask.description)).toBeInTheDocument();
    expect(screen.getByText(mockTask.assignee.name)).toBeInTheDocument();
  });
  
  it('应该显示AI建议', () => {
    const aiSuggestions = {
      priority: 'HIGH',
      estimatedHours: 8,
      recommendedAssignee: 'user-2'
    };
    
    render(
      <SmartTaskCard
        task={mockTask}
        onUpdate={mockOnUpdate}
        onAssign={mockOnAssign}
        aiSuggestions={aiSuggestions}
      />
    );
    
    const aiButton = screen.getByRole('button', { name: /AI建议/i });
    fireEvent.click(aiButton);
    
    expect(screen.getByText('建议优先级:')).toBeInTheDocument();
    expect(screen.getByText('HIGH')).toBeInTheDocument();
  });
  
  it('应该处理任务状态更新', async () => {
    render(
      <SmartTaskCard
        task={mockTask}
        onUpdate={mockOnUpdate}
        onAssign={mockOnAssign}
      />
    );
    
    const statusIcon = screen.getByTestId('task-status-icon');
    fireEvent.click(statusIcon);
    
    await waitFor(() => {
      expect(mockOnUpdate).toHaveBeenCalledWith(
        mockTask.id,
        expect.objectContaining({ status: 'IN_PROGRESS' })
      );
    });
  });
  
  it('应该支持拖拽功能', () => {
    render(
      <SmartTaskCard
        task={mockTask}
        onUpdate={mockOnUpdate}
        onAssign={mockOnAssign}
        draggable
      />
    );
    
    const card = screen.getByTestId('task-card');
    expect(card).toHaveAttribute('draggable', 'true');
  });
});
```

#### 8.1.2 Hook测试
```typescript
// __tests__/hooks/useTaskStore.test.ts
import { renderHook, act } from '@testing-library/react';
import { useTaskStore } from '@/hooks/useTaskStore';
import { mockTasks } from '../__mocks__/task-data';

// Mock fetch
global.fetch = jest.fn();

describe('useTaskStore', () => {
  beforeEach(() => {
    (fetch as jest.Mock).mockClear();
    useTaskStore.getState().tasks = [];
  });
  
  it('应该正确加载任务', async () => {
    (fetch as jest.Mock).mockResolvedValueOnce({
      ok: true,
      json: async () => mockTasks
    });
    
    const { result } = renderHook(() => useTaskStore());
    
    await act(async () => {
      await result.current.loadTasks('project-1');
    });
    
    expect(result.current.tasks).toEqual(mockTasks);
    expect(result.current.loading.tasks).toBe(false);
  });
  
  it('应该正确创建任务', async () => {
    const newTask = { title: '新任务', projectId: 'project-1' };
    const createdTask = { ...newTask, id: 'task-new', status: 'TODO' };
    
    (fetch as jest.Mock).mockResolvedValueOnce({
      ok: true,
      json: async () => createdTask
    });
    
    const { result } = renderHook(() => useTaskStore());
    
    await act(async () => {
      await result.current.createTask(newTask);
    });
    
    expect(result.current.tasks).toContainEqual(createdTask);
  });
  
  it('应该正确处理错误', async () => {
    (fetch as jest.Mock).mockRejectedValueOnce(new Error('Network error'));
    
    const { result } = renderHook(() => useTaskStore());
    
    await act(async () => {
      await result.current.loadTasks('project-1');
    });
    
    expect(result.current.error).toBe('加载任务失败');
    expect(result.current.loading.tasks).toBe(false);
  });
});
```

### 8.2 集成测试

#### 8.2.1 API集成测试
```typescript
// __tests__/api/tasks.test.ts
import { createMocks } from 'node-mocks-http';
import handler from '@/pages/api/tasks';
import { prismaMock } from '../__mocks__/prisma';

jest.mock('@/lib/prisma', () => ({
  prisma: prismaMock
}));

describe('/api/tasks', () => {
  it('POST /api/tasks - 应该创建新任务', async () => {
    const taskData = {
      title: '测试任务',
      description: '测试描述',
      projectId: 'project-1',
      creatorId: 'user-1'
    };
    
    const createdTask = {
      ...taskData,
      id: 'task-1',
      status: 'TODO',
      createdAt: new Date()
    };
    
    prismaMock.task.create.mockResolvedValue(createdTask);
    
    const { req, res } = createMocks({
      method: 'POST',
      body: taskData
    });
    
    await handler(req, res);
    
    expect(res._getStatusCode()).toBe(200);
    expect(JSON.parse(res._getData())).toEqual(
      expect.objectContaining({
        id: 'task-1',
        title: '测试任务'
      })
    );
  });
  
  it('POST /api/tasks - 应该验证必填字段', async () => {
    const { req, res } = createMocks({
      method: 'POST',
      body: {
        description: '缺少标题'
      }
    });
    
    await handler(req, res);
    
    expect(res._getStatusCode()).toBe(400);
    expect(JSON.parse(res._getData())).toEqual(
      expect.objectContaining({
        error: expect.stringContaining('验证失败')
      })
    );
  });
});
```

### 8.3 端到端测试

#### 8.3.1 Playwright测试
```typescript
// e2e/task-management.spec.ts
import { test, expect } from '@playwright/test';

test.describe('任务管理', () => {
  test.beforeEach(async ({ page }) => {
    // 登录并导航到任务管理页面
    await page.goto('/login');
    await page.fill('[data-testid="email"]', 'test@example.com');
    await page.fill('[data-testid="password"]', 'password');
    await page.click('[data-testid="login-button"]');
    await page.goto('/projects/test-project/tasks');
  });
  
  test('应该能够创建新任务', async ({ page }) => {
    // 点击创建任务按钮
    await page.click('[data-testid="create-task-button"]');
    
    // 填写任务表单
    await page.fill('[data-testid="task-title"]', '测试任务');
    await page.fill('[data-testid="task-description"]', '这是一个测试任务');
    await page.selectOption('[data-testid="task-priority"]', 'HIGH');
    
    // 提交表单
    await page.click('[data-testid="submit-task"]');
    
    // 验证任务已创建
    await expect(page.locator('[data-testid="task-list"]')).toContainText('测试任务');
  });
  
  test('应该能够拖拽任务改变状态', async ({ page }) => {
    // 等待任务列表加载
    await page.waitForSelector('[data-testid="kanban-board"]');
    
    // 拖拽任务从TODO到IN_PROGRESS
    const task = page.locator('[data-testid="task-card"]').first();
    const targetColumn = page.locator('[data-testid="column-IN_PROGRESS"]');
    
    await task.dragTo(targetColumn);
    
    // 验证任务状态已更新
    await expect(targetColumn).toContainText(await task.textContent() || '');
  });
  
  test('应该显示AI建议', async ({ page }) => {
    // 点击AI助手按钮
    await page.click('[data-testid="ai-assistant-button"]');
    
    // 输入任务描述
    await page.fill(
      '[data-testid="ai-input"]',
      '创建用户登录功能'
    );
    
    // 生成建议
    await page.click('[data-testid="generate-suggestions"]');
    
    // 等待AI建议加载
    await page.waitForSelector('[data-testid="ai-suggestions"]');
    
    // 验证建议已显示
    await expect(page.locator('[data-testid="ai-suggestions"]')).toBeVisible();
    await expect(page.locator('[data-testid="suggestion-item"]')).toHaveCount.greaterThan(0);
  });
  
  test('应该支持任务过滤', async ({ page }) => {
    // 打开过滤面板
    await page.click('[data-testid="filter-button"]');
    
    // 选择状态过滤
    await page.check('[data-testid="filter-status-TODO"]');
    await page.check('[data-testid="filter-status-IN_PROGRESS"]');
    
    // 应用过滤
    await page.click('[data-testid="apply-filters"]');
    
    // 验证只显示指定状态的任务
    const tasks = page.locator('[data-testid="task-card"]');
    const count = await tasks.count();
    
    for (let i = 0; i < count; i++) {
      const task = tasks.nth(i);
      const status = await task.getAttribute('data-status');
      expect(['TODO', 'IN_PROGRESS']).toContain(status);
    }
  });
});
```

## 9. 部署配置

### 9.1 环境变量配置

```bash
# .env.local
# 数据库配置
DATABASE_URL="mysql://user:password@localhost:3306/project_db"

# Redis配置
REDIS_URL="redis://localhost:6379"

# AI服务配置
OPENAI_API_KEY="sk-..."
OPENAI_MODEL="gpt-4"
LANGCHAIN_API_KEY="..."

# WebSocket配置
WS_PORT=3001
WS_CORS_ORIGIN="http://localhost:3000"

# 监控配置
SENTRY_DSN="https://..."
SENTRY_ENVIRONMENT="production"

# 性能配置
TASK_CACHE_TTL=300
AI_SUGGESTION_CACHE_TTL=1800
MAX_TASKS_PER_PAGE=50

# 安全配置
JWT_SECRET="your-jwt-secret"
ENCRYPTION_KEY="your-encryption-key"
CSRF_SECRET="your-csrf-secret"
```

### 9.2 Docker配置

```dockerfile
# Dockerfile
FROM node:18-alpine AS base

# 安装依赖
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

COPY package.json package-lock.json* ./
RUN npm ci --only=production

# 构建应用
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# 生成Prisma客户端
RUN npx prisma generate

# 构建Next.js应用
RUN npm run build

# 生产镜像
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

CMD ["node", "server.js"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=mysql://root:password@db:3306/project_db
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis
    volumes:
      - ./uploads:/app/uploads
  
  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: project_db
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
  
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
  
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app

volumes:
  mysql_data:
  redis_data:
```

### 9.3 性能监控配置

```typescript
// lib/monitoring/setup.ts
import * as Sentry from '@sentry/nextjs';

// Sentry配置
Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.SENTRY_ENVIRONMENT || 'development',
  tracesSampleRate: 0.1,
  beforeSend(event) {
    // 过滤敏感信息
    if (event.request?.headers) {
      delete event.request.headers.authorization;
      delete event.request.headers.cookie;
    }
    return event;
  }
});

// 自定义监控指标
export const trackTaskOperation = (operation: string, duration: number) => {
  Sentry.addBreadcrumb({
    category: 'task',
    message: `Task operation: ${operation}`,
    level: 'info',
    data: { duration }
  });
};

export const trackAIUsage = (operation: string, tokens: number) => {
  Sentry.addBreadcrumb({
    category: 'ai',
    message: `AI operation: ${operation}`,
    level: 'info',
    data: { tokens }
  });
};
```

## 10. 总结

智能任务管理页面的详细设计文档涵盖了以下关键方面：

### 10.1 核心特性
- **智能化功能**: 集成LangChain和LangGraph实现AI驱动的任务优化、分配建议和工作流自动化
- **实时协作**: WebSocket支持的实时任务更新和多用户协作
- **灵活视图**: 支持看板、列表和甘特图多种视图模式
- **高性能**: 虚拟化列表、缓存策略和优化的数据库查询

### 10.2 技术架构
- **前端**: React + TypeScript + Zustand状态管理 + shadcn/ui组件库
- **后端**: Next.js API Routes + Prisma ORM + MySQL数据库
- **AI集成**: LangChain链式调用 + LangGraph工作流引擎
- **缓存**: Redis缓存层提升性能
- **实时通信**: WebSocket实现实时协作

### 10.3 用户体验
- **直观界面**: 现代化的卡片式设计和拖拽交互
- **智能助手**: AI驱动的任务建议和优化
- **响应式设计**: 支持桌面和移动端访问
- **错误处理**: 完善的错误边界和用户友好的错误提示

### 10.4 可扩展性
- **模块化架构**: 组件化设计便于维护和扩展
- **插件化AI**: 支持不同AI模型和工作流的集成
- **微服务就绪**: 支持容器化部署和水平扩展
- **监控完善**: 全面的性能监控和错误追踪

该设计文档为智能任务管理页面的开发提供了完整的技术方案和实施指导，确保功能的完整性、性能的优化和用户体验的卓越。