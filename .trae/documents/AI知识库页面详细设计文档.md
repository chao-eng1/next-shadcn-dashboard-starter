# AIçŸ¥è¯†åº“é¡µé¢è¯¦ç»†è®¾è®¡æ–‡æ¡£

## 1. é¡µé¢æ¦‚è¿°

AIçŸ¥è¯†åº“é¡µé¢æ˜¯ä¸€ä¸ªæ™ºèƒ½åŒ–çš„çŸ¥è¯†ç®¡ç†ç³»ç»Ÿï¼Œé›†æˆäº†LangChainå’ŒLangGraphæŠ€æœ¯ï¼Œä¸ºç”¨æˆ·æä¾›æ™ºèƒ½æ–‡æ¡£ç®¡ç†ã€çŸ¥è¯†æ£€ç´¢ã€å†…å®¹ç”Ÿæˆå’ŒçŸ¥è¯†å›¾è°±æ„å»ºç­‰åŠŸèƒ½ã€‚è¯¥é¡µé¢æ—¨åœ¨å¸®åŠ©å›¢é˜Ÿé«˜æ•ˆåœ°ç»„ç»‡ã€ç®¡ç†å’Œåˆ©ç”¨çŸ¥è¯†èµ„äº§ã€‚

### 1.1 æ ¸å¿ƒä»·å€¼

- **æ™ºèƒ½æ£€ç´¢**: åŸºäºè¯­ä¹‰ç†è§£çš„æ™ºèƒ½æœç´¢å’Œæ¨è
- **çŸ¥è¯†å›¾è°±**: è‡ªåŠ¨æ„å»ºçŸ¥è¯†ä¹‹é—´çš„å…³è”å…³ç³»
- **å†…å®¹ç”Ÿæˆ**: AIè¾…åŠ©çš„æ–‡æ¡£åˆ›å»ºå’Œå†…å®¹ä¼˜åŒ–
- **åä½œå…±äº«**: å›¢é˜ŸçŸ¥è¯†çš„åä½œç¼–è¾‘å’Œå…±äº«æœºåˆ¶

### 1.2 ç›®æ ‡ç”¨æˆ·

- **çŸ¥è¯†å·¥ä½œè€…**: éœ€è¦ç®¡ç†å¤§é‡æ–‡æ¡£å’Œèµ„æ–™çš„ä¸“ä¸šäººå‘˜
- **ç ”ç©¶å›¢é˜Ÿ**: éœ€è¦åä½œæ•´ç†å’Œåˆ†äº«ç ”ç©¶æˆæœçš„å›¢é˜Ÿ
- **é¡¹ç›®ç»ç†**: éœ€è¦ç»´æŠ¤é¡¹ç›®çŸ¥è¯†åº“çš„ç®¡ç†äººå‘˜
- **æŠ€æœ¯å›¢é˜Ÿ**: éœ€è¦æ„å»ºæŠ€æœ¯æ–‡æ¡£å’Œæœ€ä½³å®è·µåº“çš„å¼€å‘å›¢é˜Ÿ

## 2. åŠŸèƒ½éœ€æ±‚

### 2.1 æ™ºèƒ½æ–‡æ¡£ç®¡ç†

- **æ–‡æ¡£ä¸Šä¼ **: æ”¯æŒå¤šç§æ ¼å¼æ–‡æ¡£çš„æ‰¹é‡ä¸Šä¼ å’Œè§£æ
- **è‡ªåŠ¨åˆ†ç±»**: AIè‡ªåŠ¨è¯†åˆ«æ–‡æ¡£ç±»å‹å’Œä¸»é¢˜è¿›è¡Œåˆ†ç±»
- **ç‰ˆæœ¬æ§åˆ¶**: æ–‡æ¡£ç‰ˆæœ¬ç®¡ç†å’Œå˜æ›´è¿½è¸ª
- **æƒé™ç®¡ç†**: ç»†ç²’åº¦çš„æ–‡æ¡£è®¿é—®å’Œç¼–è¾‘æƒé™æ§åˆ¶

### 2.2 æ™ºèƒ½æ£€ç´¢ç³»ç»Ÿ

- **è¯­ä¹‰æœç´¢**: åŸºäºå†…å®¹ç†è§£çš„æ™ºèƒ½æœç´¢
- **ç›¸å…³æ¨è**: æ ¹æ®ç”¨æˆ·è¡Œä¸ºå’Œå†…å®¹ç›¸ä¼¼æ€§æ¨èç›¸å…³æ–‡æ¡£
- **å¿«é€Ÿé¢„è§ˆ**: æœç´¢ç»“æœçš„å¿«é€Ÿé¢„è§ˆå’Œé«˜äº®æ˜¾ç¤º
- **æœç´¢å†å²**: ä¸ªäººæœç´¢å†å²å’Œå¸¸ç”¨æŸ¥è¯¢ç®¡ç†

### 2.3 AIå†…å®¹åŠ©æ‰‹

- **æ™ºèƒ½æ‘˜è¦**: è‡ªåŠ¨ç”Ÿæˆæ–‡æ¡£æ‘˜è¦å’Œå…³é”®ä¿¡æ¯æå–
- **å†…å®¹ç”Ÿæˆ**: AIè¾…åŠ©çš„æ–‡æ¡£åˆ›å»ºå’Œå†…å®¹æ‰©å±•
- **ç¿»è¯‘æœåŠ¡**: å¤šè¯­è¨€æ–‡æ¡£çš„æ™ºèƒ½ç¿»è¯‘
- **è´¨é‡æ£€æŸ¥**: æ–‡æ¡£è´¨é‡è¯„ä¼°å’Œæ”¹è¿›å»ºè®®

### 2.4 çŸ¥è¯†å›¾è°±

- **å…³ç³»å‘ç°**: è‡ªåŠ¨å‘ç°æ–‡æ¡£å’Œæ¦‚å¿µä¹‹é—´çš„å…³è”
- **å¯è§†åŒ–å±•ç¤º**: çŸ¥è¯†å…³ç³»çš„å›¾å½¢åŒ–å±•ç¤º
- **è·¯å¾„åˆ†æ**: çŸ¥è¯†ç‚¹ä¹‹é—´çš„å…³è”è·¯å¾„åˆ†æ
- **å›¾è°±å¯¼èˆª**: åŸºäºçŸ¥è¯†å›¾è°±çš„å¯¼èˆªå’Œæ¢ç´¢

### 2.5 åä½œåŠŸèƒ½

- **å®æ—¶ç¼–è¾‘**: å¤šäººåä½œçš„å®æ—¶æ–‡æ¡£ç¼–è¾‘
- **è¯„è®ºç³»ç»Ÿ**: æ–‡æ¡£è¯„è®ºå’Œè®¨è®ºåŠŸèƒ½
- **åˆ†äº«æœºåˆ¶**: çµæ´»çš„æ–‡æ¡£åˆ†äº«å’Œæƒé™è®¾ç½®
- **é€šçŸ¥æé†’**: æ–‡æ¡£æ›´æ–°å’Œåä½œæ´»åŠ¨çš„é€šçŸ¥

### 2.6 ç”¨æˆ·è§’è‰²æƒé™

| è§’è‰²       | æƒé™æè¿°                                     |
| ---------- | -------------------------------------------- |
| çŸ¥è¯†ç®¡ç†å‘˜ | å…¨éƒ¨æƒé™ï¼šç®¡ç†çŸ¥è¯†åº“ç»“æ„ã€ç”¨æˆ·æƒé™ã€ç³»ç»Ÿé…ç½® |
| å†…å®¹ç¼–è¾‘è€… | åˆ›å»ºã€ç¼–è¾‘ã€åˆ é™¤æ–‡æ¡£ï¼Œç®¡ç†åˆ†ç±»å’Œæ ‡ç­¾         |
| åä½œè€…     | ç¼–è¾‘æŒ‡å®šæ–‡æ¡£ï¼Œæ·»åŠ è¯„è®ºï¼Œå‚ä¸åä½œ             |
| æŸ¥çœ‹è€…     | æµè§ˆå’Œæœç´¢æ–‡æ¡£ï¼ŒæŸ¥çœ‹å…¬å¼€å†…å®¹                 |

## 3. å‰ç«¯è®¾è®¡

### 3.1 é¡µé¢å¸ƒå±€

```typescript
// components/KnowledgeBasePage.tsx
import React, { useState, useEffect } from 'react';
import { Search, Plus, Filter, Grid, List, BookOpen, Brain } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { KnowledgeSearchBar } from './KnowledgeSearchBar';
import { DocumentGrid } from './DocumentGrid';
import { KnowledgeGraph } from './KnowledgeGraph';
import { AIAssistantPanel } from './AIAssistantPanel';
import { DocumentEditor } from './DocumentEditor';

interface KnowledgeBasePageProps {
  projectId: string;
}

export const KnowledgeBasePage: React.FC<KnowledgeBasePageProps> = ({
  projectId
}) => {
  const [activeView, setActiveView] = useState<'grid' | 'list' | 'graph'>('grid');
  const [selectedDocument, setSelectedDocument] = useState<string | null>(null);
  const [showAIAssistant, setShowAIAssistant] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [filters, setFilters] = useState({
    category: [],
    tags: [],
    dateRange: null,
    author: []
  });

  return (
    <div className="flex h-screen bg-gray-50">
      {/* ä¾§è¾¹æ  */}
      <div className="w-80 bg-white border-r border-gray-200 flex flex-col">
        {/* æœç´¢åŒºåŸŸ */}
        <div className="p-4 border-b border-gray-200">
          <KnowledgeSearchBar
            value={searchQuery}
            onChange={setSearchQuery}
            onSearch={(query) => {
              // æ‰§è¡Œæœç´¢é€»è¾‘
            }}
            placeholder="æœç´¢çŸ¥è¯†åº“..."
          />
        </div>

        {/* åˆ†ç±»å¯¼èˆª */}
        <div className="flex-1 overflow-y-auto">
          <CategoryNavigation
            projectId={projectId}
            onCategorySelect={(category) => {
              setFilters(prev => ({
                ...prev,
                category: [category]
              }));
            }}
          />
        </div>

        {/* å¿«æ·æ“ä½œ */}
        <div className="p-4 border-t border-gray-200">
          <div className="space-y-2">
            <Button
              onClick={() => setSelectedDocument('new')}
              className="w-full"
              size="sm"
            >
              <Plus className="w-4 h-4 mr-2" />
              æ–°å»ºæ–‡æ¡£
            </Button>

            <Button
              onClick={() => setShowAIAssistant(!showAIAssistant)}
              variant="outline"
              className="w-full"
              size="sm"
            >
              <Brain className="w-4 h-4 mr-2" />
              AIåŠ©æ‰‹
            </Button>
          </div>
        </div>
      </div>

      {/* ä¸»å†…å®¹åŒºåŸŸ */}
      <div className="flex-1 flex flex-col">
        {/* å·¥å…·æ  */}
        <div className="bg-white border-b border-gray-200 p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4">
              <h1 className="text-xl font-semibold text-gray-900">
                çŸ¥è¯†åº“
              </h1>

              <div className="flex items-center space-x-2">
                <Button
                  variant={activeView === 'grid' ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setActiveView('grid')}
                >
                  <Grid className="w-4 h-4" />
                </Button>

                <Button
                  variant={activeView === 'list' ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setActiveView('list')}
                >
                  <List className="w-4 h-4" />
                </Button>

                <Button
                  variant={activeView === 'graph' ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setActiveView('graph')}
                >
                  <BookOpen className="w-4 h-4" />
                </Button>
              </div>
            </div>

            <div className="flex items-center space-x-2">
              <FilterPanel
                filters={filters}
                onFiltersChange={setFilters}
              />

              <Button size="sm">
                <Plus className="w-4 h-4 mr-2" />
                ä¸Šä¼ æ–‡æ¡£
              </Button>
            </div>
          </div>
        </div>

        {/* å†…å®¹å±•ç¤ºåŒºåŸŸ */}
        <div className="flex-1 overflow-hidden">
          {selectedDocument ? (
            <DocumentEditor
              documentId={selectedDocument}
              onClose={() => setSelectedDocument(null)}
              onSave={(document) => {
                // ä¿å­˜æ–‡æ¡£é€»è¾‘
              }}
            />
          ) : (
            <Tabs value={activeView} className="h-full">
              <TabsContent value="grid" className="h-full">
                <DocumentGrid
                  projectId={projectId}
                  searchQuery={searchQuery}
                  filters={filters}
                  onDocumentSelect={setSelectedDocument}
                />
              </TabsContent>

              <TabsContent value="list" className="h-full">
                <DocumentList
                  projectId={projectId}
                  searchQuery={searchQuery}
                  filters={filters}
                  onDocumentSelect={setSelectedDocument}
                />
              </TabsContent>

              <TabsContent value="graph" className="h-full">
                <KnowledgeGraph
                  projectId={projectId}
                  onNodeSelect={(nodeId) => {
                    if (nodeId.startsWith('doc_')) {
                      setSelectedDocument(nodeId.replace('doc_', ''));
                    }
                  }}
                />
              </TabsContent>
            </Tabs>
          )}
        </div>
      </div>

      {/* AIåŠ©æ‰‹é¢æ¿ */}
      {showAIAssistant && (
        <AIAssistantPanel
          projectId={projectId}
          context={{
            currentDocument: selectedDocument,
            searchQuery,
            selectedDocuments: []
          }}
          onClose={() => setShowAIAssistant(false)}
          onAction={(action, data) => {
            // å¤„ç†AIåŠ©æ‰‹æ“ä½œ
          }}
        />
      )}
    </div>
  );
};
```

### 3.2 UIç»„ä»¶è®¾è®¡

#### 3.2.1 æ™ºèƒ½æœç´¢ç»„ä»¶

```typescript
// components/KnowledgeSearchBar.tsx
import React, { useState, useRef, useEffect } from 'react';
import { Search, Clock, Sparkles, X } from 'lucide-react';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { useDebounce } from '@/hooks/useDebounce';
import { useKnowledgeSearch } from '@/hooks/useKnowledgeSearch';

interface KnowledgeSearchBarProps {
  value: string;
  onChange: (value: string) => void;
  onSearch: (query: string) => void;
  placeholder?: string;
}

export const KnowledgeSearchBar: React.FC<KnowledgeSearchBarProps> = ({
  value,
  onChange,
  onSearch,
  placeholder = 'æœç´¢çŸ¥è¯†åº“...'
}) => {
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [recentSearches, setRecentSearches] = useState<string[]>([]);
  const inputRef = useRef<HTMLInputElement>(null);
  const debouncedQuery = useDebounce(value, 300);

  const {
    suggestions,
    loading: suggestionsLoading
  } = useKnowledgeSearch(debouncedQuery);

  useEffect(() => {
    // åŠ è½½æœ€è¿‘æœç´¢å†å²
    const recent = localStorage.getItem('knowledge_recent_searches');
    if (recent) {
      setRecentSearches(JSON.parse(recent));
    }
  }, []);

  const handleSearch = (query: string) => {
    if (!query.trim()) return;

    // æ·»åŠ åˆ°æœç´¢å†å²
    const newRecentSearches = [query, ...recentSearches.filter(s => s !== query)].slice(0, 5);
    setRecentSearches(newRecentSearches);
    localStorage.setItem('knowledge_recent_searches', JSON.stringify(newRecentSearches));

    onSearch(query);
    setShowSuggestions(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleSearch(value);
    } else if (e.key === 'Escape') {
      setShowSuggestions(false);
    }
  };

  return (
    <div className="relative">
      <div className="relative">
        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
        <Input
          ref={inputRef}
          value={value}
          onChange={(e) => onChange(e.target.value)}
          onKeyDown={handleKeyDown}
          onFocus={() => setShowSuggestions(true)}
          placeholder={placeholder}
          className="pl-10 pr-10"
        />
        {value && (
          <Button
            variant="ghost"
            size="sm"
            className="absolute right-1 top-1/2 transform -translate-y-1/2 h-6 w-6 p-0"
            onClick={() => {
              onChange('');
              inputRef.current?.focus();
            }}
          >
            <X className="w-3 h-3" />
          </Button>
        )}
      </div>

      {/* æœç´¢å»ºè®®ä¸‹æ‹‰æ¡† */}
      {showSuggestions && (
        <div className="absolute top-full left-0 right-0 mt-1 bg-white border border-gray-200 rounded-md shadow-lg z-50 max-h-80 overflow-y-auto">
          {/* AIæ™ºèƒ½å»ºè®® */}
          {suggestions.length > 0 && (
            <div className="p-2">
              <div className="flex items-center text-xs text-gray-500 mb-2">
                <Sparkles className="w-3 h-3 mr-1" />
                æ™ºèƒ½å»ºè®®
              </div>
              {suggestions.map((suggestion, index) => (
                <button
                  key={index}
                  className="w-full text-left px-3 py-2 hover:bg-gray-50 rounded text-sm"
                  onClick={() => {
                    onChange(suggestion.query);
                    handleSearch(suggestion.query);
                  }}
                >
                  <div className="font-medium">{suggestion.query}</div>
                  {suggestion.description && (
                    <div className="text-xs text-gray-500 mt-1">
                      {suggestion.description}
                    </div>
                  )}
                </button>
              ))}
            </div>
          )}

          {/* æœ€è¿‘æœç´¢ */}
          {recentSearches.length > 0 && (
            <div className="p-2 border-t border-gray-100">
              <div className="flex items-center text-xs text-gray-500 mb-2">
                <Clock className="w-3 h-3 mr-1" />
                æœ€è¿‘æœç´¢
              </div>
              {recentSearches.map((search, index) => (
                <button
                  key={index}
                  className="w-full text-left px-3 py-2 hover:bg-gray-50 rounded text-sm flex items-center justify-between"
                  onClick={() => {
                    onChange(search);
                    handleSearch(search);
                  }}
                >
                  <span>{search}</span>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-4 w-4 p-0 opacity-0 group-hover:opacity-100"
                    onClick={(e) => {
                      e.stopPropagation();
                      const newRecentSearches = recentSearches.filter((_, i) => i !== index);
                      setRecentSearches(newRecentSearches);
                      localStorage.setItem('knowledge_recent_searches', JSON.stringify(newRecentSearches));
                    }}
                  >
                    <X className="w-3 h-3" />
                  </Button>
                </button>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
};
```

#### 3.2.2 æ–‡æ¡£å¡ç‰‡ç»„ä»¶

```typescript
// components/DocumentCard.tsx
import React, { useState } from 'react';
import { FileText, Download, Share, Edit, Trash2, Eye, Clock, User, Tag } from 'lucide-react';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { formatDistanceToNow } from 'date-fns';
import { zhCN } from 'date-fns/locale';

interface Document {
  id: string;
  title: string;
  description?: string;
  content: string;
  category: string;
  tags: string[];
  author: {
    id: string;
    name: string;
    avatar?: string;
  };
  createdAt: Date;
  updatedAt: Date;
  viewCount: number;
  downloadCount: number;
  fileType: string;
  fileSize: number;
  aiSummary?: string;
  relevanceScore?: number;
}

interface DocumentCardProps {
  document: Document;
  onSelect: (documentId: string) => void;
  onEdit: (documentId: string) => void;
  onDelete: (documentId: string) => void;
  onShare: (documentId: string) => void;
  showAISummary?: boolean;
  highlighted?: string[];
}

export const DocumentCard: React.FC<DocumentCardProps> = ({
  document,
  onSelect,
  onEdit,
  onDelete,
  onShare,
  showAISummary = false,
  highlighted = []
}) => {
  const [showFullSummary, setShowFullSummary] = useState(false);

  const getFileIcon = (fileType: string) => {
    switch (fileType.toLowerCase()) {
      case 'pdf':
        return 'ğŸ“„';
      case 'doc':
      case 'docx':
        return 'ğŸ“';
      case 'ppt':
      case 'pptx':
        return 'ğŸ“Š';
      case 'xls':
      case 'xlsx':
        return 'ğŸ“ˆ';
      default:
        return 'ğŸ“„';
    }
  };

  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  const highlightText = (text: string, highlights: string[]) => {
    if (!highlights.length) return text;

    let highlightedText = text;
    highlights.forEach(highlight => {
      const regex = new RegExp(`(${highlight})`, 'gi');
      highlightedText = highlightedText.replace(regex, '<mark>$1</mark>');
    });

    return <span dangerouslySetInnerHTML={{ __html: highlightedText }} />;
  };

  return (
    <Card className="group hover:shadow-md transition-shadow duration-200 cursor-pointer">
      <CardHeader className="pb-3">
        <div className="flex items-start justify-between">
          <div className="flex items-start space-x-3 flex-1">
            <div className="text-2xl">{getFileIcon(document.fileType)}</div>

            <div className="flex-1 min-w-0">
              <h3
                className="font-medium text-gray-900 truncate hover:text-blue-600 transition-colors"
                onClick={() => onSelect(document.id)}
              >
                {highlightText(document.title, highlighted)}
              </h3>

              {document.description && (
                <p className="text-sm text-gray-600 mt-1 line-clamp-2">
                  {highlightText(document.description, highlighted)}
                </p>
              )}

              {/* AIæ‘˜è¦ */}
              {showAISummary && document.aiSummary && (
                <div className="mt-2 p-2 bg-blue-50 rounded-md">
                  <div className="flex items-center text-xs text-blue-600 mb-1">
                    <Sparkles className="w-3 h-3 mr-1" />
                    AIæ‘˜è¦
                  </div>
                  <p className="text-sm text-gray-700">
                    {showFullSummary
                      ? document.aiSummary
                      : `${document.aiSummary.slice(0, 100)}${document.aiSummary.length > 100 ? '...' : ''}`
                    }
                    {document.aiSummary.length > 100 && (
                      <button
                        className="text-blue-600 hover:text-blue-800 ml-1 text-xs"
                        onClick={(e) => {
                          e.stopPropagation();
                          setShowFullSummary(!showFullSummary);
                        }}
                      >
                        {showFullSummary ? 'æ”¶èµ·' : 'å±•å¼€'}
                      </button>
                    )}
                  </p>
                </div>
              )}
            </div>
          </div>

          {/* ç›¸å…³æ€§è¯„åˆ† */}
          {document.relevanceScore && (
            <Badge variant="secondary" className="ml-2">
              {Math.round(document.relevanceScore * 100)}%
            </Badge>
          )}
        </div>

        {/* æ ‡ç­¾ */}
        {document.tags.length > 0 && (
          <div className="flex flex-wrap gap-1 mt-2">
            {document.tags.slice(0, 3).map((tag, index) => (
              <Badge key={index} variant="outline" className="text-xs">
                <Tag className="w-3 h-3 mr-1" />
                {tag}
              </Badge>
            ))}
            {document.tags.length > 3 && (
              <Badge variant="outline" className="text-xs">
                +{document.tags.length - 3}
              </Badge>
            )}
          </div>
        )}
      </CardHeader>

      <CardContent className="pt-0">
        {/* æ–‡æ¡£ä¿¡æ¯ */}
        <div className="flex items-center justify-between text-xs text-gray-500 mb-3">
          <div className="flex items-center space-x-4">
            <div className="flex items-center">
              <User className="w-3 h-3 mr-1" />
              <Avatar className="w-4 h-4 mr-1">
                <AvatarImage src={document.author.avatar} />
                <AvatarFallback className="text-xs">
                  {document.author.name.charAt(0)}
                </AvatarFallback>
              </Avatar>
              <span>{document.author.name}</span>
            </div>

            <div className="flex items-center">
              <Clock className="w-3 h-3 mr-1" />
              <span>
                {formatDistanceToNow(document.updatedAt, {
                  addSuffix: true,
                  locale: zhCN
                })}
              </span>
            </div>
          </div>

          <div className="flex items-center space-x-2">
            <span>{formatFileSize(document.fileSize)}</span>
            <span>â€¢</span>
            <div className="flex items-center">
              <Eye className="w-3 h-3 mr-1" />
              <span>{document.viewCount}</span>
            </div>
          </div>
        </div>

        {/* æ“ä½œæŒ‰é’® */}
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-1">
            <Button
              variant="ghost"
              size="sm"
              className="h-7 px-2 opacity-0 group-hover:opacity-100 transition-opacity"
              onClick={(e) => {
                e.stopPropagation();
                onEdit(document.id);
              }}
            >
              <Edit className="w-3 h-3" />
            </Button>

            <Button
              variant="ghost"
              size="sm"
              className="h-7 px-2 opacity-0 group-hover:opacity-100 transition-opacity"
              onClick={(e) => {
                e.stopPropagation();
                onShare(document.id);
              }}
            >
              <Share className="w-3 h-3" />
            </Button>

            <Button
              variant="ghost"
              size="sm"
              className="h-7 px-2 opacity-0 group-hover:opacity-100 transition-opacity"
              onClick={(e) => {
                e.stopPropagation();
                // ä¸‹è½½é€»è¾‘
              }}
            >
              <Download className="w-3 h-3" />
            </Button>

            <Button
              variant="ghost"
              size="sm"
              className="h-7 px-2 opacity-0 group-hover:opacity-100 transition-opacity text-red-600 hover:text-red-700"
              onClick={(e) => {
                e.stopPropagation();
                onDelete(document.id);
              }}
            >
              <Trash2 className="w-3 h-3" />
            </Button>
          </div>

          <Badge variant="outline" className="text-xs">
            {document.category}
          </Badge>
        </div>
      </CardContent>
    </Card>
  );
};
```

#### 3.2.3 çŸ¥è¯†å›¾è°±ç»„ä»¶

```typescript
// components/KnowledgeGraph.tsx
import React, { useEffect, useRef, useState } from 'react';
import * as d3 from 'd3';
import { Button } from '@/components/ui/button';
import { ZoomIn, ZoomOut, RotateCcw, Search } from 'lucide-react';
import { Input } from '@/components/ui/input';
import { useKnowledgeGraph } from '@/hooks/useKnowledgeGraph';

interface GraphNode {
  id: string;
  label: string;
  type: 'document' | 'concept' | 'person' | 'project';
  size: number;
  color: string;
  metadata: any;
}

interface GraphLink {
  source: string;
  target: string;
  weight: number;
  type: 'reference' | 'similarity' | 'collaboration' | 'dependency';
  label?: string;
}

interface KnowledgeGraphProps {
  projectId: string;
  onNodeSelect: (nodeId: string) => void;
  height?: number;
}

export const KnowledgeGraph: React.FC<KnowledgeGraphProps> = ({
  projectId,
  onNodeSelect,
  height = 600
}) => {
  const svgRef = useRef<SVGSVGElement>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedNode, setSelectedNode] = useState<string | null>(null);
  const [zoomLevel, setZoomLevel] = useState(1);

  const {
    nodes,
    links,
    loading,
    error,
    refreshGraph
  } = useKnowledgeGraph(projectId);

  useEffect(() => {
    if (!nodes.length || !svgRef.current) return;

    const svg = d3.select(svgRef.current);
    const width = svgRef.current.clientWidth;

    // æ¸…é™¤ä¹‹å‰çš„å†…å®¹
    svg.selectAll('*').remove();

    // åˆ›å»ºç¼©æ”¾è¡Œä¸º
    const zoom = d3.zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        container.attr('transform', event.transform);
        setZoomLevel(event.transform.k);
      });

    svg.call(zoom);

    // åˆ›å»ºå®¹å™¨ç»„
    const container = svg.append('g');

    // åˆ›å»ºåŠ›å¯¼å‘å›¾æ¨¡æ‹Ÿ
    const simulation = d3.forceSimulation<GraphNode>(nodes)
      .force('link', d3.forceLink<GraphNode, GraphLink>(links)
        .id(d => d.id)
        .distance(d => 100 / (d.weight || 1))
      )
      .force('charge', d3.forceManyBody().strength(-300))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius(d => d.size + 5));

    // åˆ›å»ºè¿çº¿
    const link = container.append('g')
      .selectAll('line')
      .data(links)
      .enter().append('line')
      .attr('stroke', '#999')
      .attr('stroke-opacity', 0.6)
      .attr('stroke-width', d => Math.sqrt(d.weight || 1));

    // åˆ›å»ºè¿çº¿æ ‡ç­¾
    const linkLabel = container.append('g')
      .selectAll('text')
      .data(links.filter(d => d.label))
      .enter().append('text')
      .attr('font-size', '10px')
      .attr('fill', '#666')
      .attr('text-anchor', 'middle')
      .text(d => d.label || '');

    // åˆ›å»ºèŠ‚ç‚¹ç»„
    const node = container.append('g')
      .selectAll('g')
      .data(nodes)
      .enter().append('g')
      .attr('class', 'node')
      .style('cursor', 'pointer')
      .call(d3.drag<SVGGElement, GraphNode>()
        .on('start', (event, d) => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        })
        .on('drag', (event, d) => {
          d.fx = event.x;
          d.fy = event.y;
        })
        .on('end', (event, d) => {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        })
      );

    // æ·»åŠ èŠ‚ç‚¹åœ†åœˆ
    node.append('circle')
      .attr('r', d => d.size)
      .attr('fill', d => d.color)
      .attr('stroke', '#fff')
      .attr('stroke-width', 2)
      .on('click', (event, d) => {
        setSelectedNode(d.id);
        onNodeSelect(d.id);
      })
      .on('mouseover', function(event, d) {
        // é«˜äº®ç›¸å…³èŠ‚ç‚¹å’Œè¿çº¿
        const connectedNodes = new Set();
        links.forEach(link => {
          if (link.source === d.id || link.target === d.id) {
            connectedNodes.add(link.source);
            connectedNodes.add(link.target);
          }
        });

        node.style('opacity', n => connectedNodes.has(n.id) ? 1 : 0.3);
        link.style('opacity', l =>
          l.source === d.id || l.target === d.id ? 1 : 0.1
        );
      })
      .on('mouseout', () => {
        node.style('opacity', 1);
        link.style('opacity', 0.6);
      });

    // æ·»åŠ èŠ‚ç‚¹æ ‡ç­¾
    node.append('text')
      .attr('dy', d => d.size + 15)
      .attr('text-anchor', 'middle')
      .attr('font-size', '12px')
      .attr('fill', '#333')
      .text(d => d.label.length > 15 ? d.label.slice(0, 15) + '...' : d.label);

    // æ·»åŠ èŠ‚ç‚¹ç±»å‹å›¾æ ‡
    node.append('text')
      .attr('text-anchor', 'middle')
      .attr('dy', '0.35em')
      .attr('font-size', d => d.size * 0.8)
      .text(d => {
        switch (d.type) {
          case 'document': return 'ğŸ“„';
          case 'concept': return 'ğŸ’¡';
          case 'person': return 'ğŸ‘¤';
          case 'project': return 'ğŸ“';
          default: return 'âšª';
        }
      });

    // æ›´æ–°ä½ç½®
    simulation.on('tick', () => {
      link
        .attr('x1', d => (d.source as any).x)
        .attr('y1', d => (d.source as any).y)
        .attr('x2', d => (d.target as any).x)
        .attr('y2', d => (d.target as any).y);

      linkLabel
        .attr('x', d => ((d.source as any).x + (d.target as any).x) / 2)
        .attr('y', d => ((d.source as any).y + (d.target as any).y) / 2);

      node.attr('transform', d => `translate(${d.x},${d.y})`);
    });

    // æœç´¢é«˜äº®
    if (searchTerm) {
      node.select('circle')
        .attr('stroke', d =>
          d.label.toLowerCase().includes(searchTerm.toLowerCase())
            ? '#ff6b6b' : '#fff'
        )
        .attr('stroke-width', d =>
          d.label.toLowerCase().includes(searchTerm.toLowerCase()) ? 3 : 2
        );
    }

    return () => {
      simulation.stop();
    };
  }, [nodes, links, searchTerm, height]);

  const handleZoomIn = () => {
    const svg = d3.select(svgRef.current);
    svg.transition().call(
      d3.zoom<SVGSVGElement, unknown>().scaleBy as any,
      1.5
    );
  };

  const handleZoomOut = () => {
    const svg = d3.select(svgRef.current);
    svg.transition().call(
      d3.zoom<SVGSVGElement, unknown>().scaleBy as any,
      1 / 1.5
    );
  };

  const handleReset = () => {
    const svg = d3.select(svgRef.current);
    svg.transition().call(
      d3.zoom<SVGSVGElement, unknown>().transform as any,
      d3.zoomIdentity
    );
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-2"></div>
          <p className="text-gray-600">æ­£åœ¨æ„å»ºçŸ¥è¯†å›¾è°±...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-center">
          <p className="text-red-600 mb-2">åŠ è½½çŸ¥è¯†å›¾è°±å¤±è´¥</p>
          <Button onClick={refreshGraph} size="sm">
            é‡è¯•
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="relative h-full bg-white">
      {/* æ§åˆ¶é¢æ¿ */}
      <div className="absolute top-4 left-4 z-10 bg-white rounded-lg shadow-md p-3 space-y-2">
        <div className="flex items-center space-x-2">
          <Search className="w-4 h-4 text-gray-400" />
          <Input
            placeholder="æœç´¢èŠ‚ç‚¹..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-40 h-8"
          />
        </div>

        <div className="flex items-center space-x-1">
          <Button
            variant="outline"
            size="sm"
            onClick={handleZoomIn}
            className="h-8 w-8 p-0"
          >
            <ZoomIn className="w-4 h-4" />
          </Button>

          <Button
            variant="outline"
            size="sm"
            onClick={handleZoomOut}
            className="h-8 w-8 p-0"
          >
            <ZoomOut className="w-4 h-4" />
          </Button>

          <Button
            variant="outline"
            size="sm"
            onClick={handleReset}
            className="h-8 w-8 p-0"
          >
            <RotateCcw className="w-4 h-4" />
          </Button>
        </div>

        <div className="text-xs text-gray-500">
          ç¼©æ”¾: {Math.round(zoomLevel * 100)}%
        </div>
      </div>

      {/* å›¾ä¾‹ */}
      <div className="absolute top-4 right-4 z-10 bg-white rounded-lg shadow-md p-3">
        <h4 className="text-sm font-medium mb-2">å›¾ä¾‹</h4>
        <div className="space-y-1 text-xs">
          <div className="flex items-center space-x-2">
            <span>ğŸ“„</span>
            <span>æ–‡æ¡£</span>
          </div>
          <div className="flex items-center space-x-2">
            <span>ğŸ’¡</span>
            <span>æ¦‚å¿µ</span>
          </div>
          <div className="flex items-center space-x-2">
            <span>ğŸ‘¤</span>
            <span>äººå‘˜</span>
          </div>
          <div className="flex items-center space-x-2">
            <span>ğŸ“</span>
            <span>é¡¹ç›®</span>
          </div>
        </div>
      </div>

      {/* å›¾è°±ç”»å¸ƒ */}
      <svg
        ref={svgRef}
        width="100%"
        height={height}
        className="border border-gray-200"
      />

      {/* èŠ‚ç‚¹ä¿¡æ¯é¢æ¿ */}
      {selectedNode && (
        <div className="absolute bottom-4 left-4 z-10 bg-white rounded-lg shadow-md p-4 max-w-sm">
          <NodeInfoPanel
            nodeId={selectedNode}
            onClose={() => setSelectedNode(null)}
          />
        </div>
      )}
    </div>
  );
};
```

### 3.3 çŠ¶æ€ç®¡ç†

```typescript
// hooks/useKnowledgeStore.ts
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

interface Document {
  id: string;
  title: string;
  description?: string;
  content: string;
  category: string;
  tags: string[];
  author: {
    id: string;
    name: string;
    avatar?: string;
  };
  createdAt: Date;
  updatedAt: Date;
  viewCount: number;
  downloadCount: number;
  fileType: string;
  fileSize: number;
  aiSummary?: string;
  relevanceScore?: number;
}

interface SearchFilters {
  category: string[];
  tags: string[];
  dateRange: {
    start: Date | null;
    end: Date | null;
  } | null;
  author: string[];
  fileType: string[];
}

interface KnowledgeState {
  documents: Document[];
  categories: string[];
  tags: string[];
  searchQuery: string;
  searchResults: Document[];
  filters: SearchFilters;
  selectedDocument: string | null;
  loading: {
    documents: boolean;
    search: boolean;
    upload: boolean;
  };
  error: string | null;
}

interface KnowledgeActions {
  // æ–‡æ¡£ç®¡ç†
  loadDocuments: (projectId: string) => Promise<void>;
  createDocument: (document: Partial<Document>) => Promise<void>;
  updateDocument: (documentId: string, updates: Partial<Document>) => Promise<void>;
  deleteDocument: (documentId: string) => Promise<void>;

  // æœç´¢åŠŸèƒ½
  search: (query: string, filters?: Partial<SearchFilters>) => Promise<void>;
  setSearchQuery: (query: string) => void;
  setFilters: (filters: Partial<SearchFilters>) => void;
  clearSearch: () => void;

  // æ–‡æ¡£æ“ä½œ
  selectDocument: (documentId: string | null) => void;
  incrementViewCount: (documentId: string) => void;
  incrementDownloadCount: (documentId: string) => void;

  // AIåŠŸèƒ½
  generateSummary: (documentId: string) => Promise<void>;
  generateTags: (documentId: string) => Promise<void>;
  findSimilarDocuments: (documentId: string) => Promise<Document[]>;

  // åˆ†ç±»å’Œæ ‡ç­¾
  loadCategories: (projectId: string) => Promise<void>;
  loadTags: (projectId: string) => Promise<void>;
  createCategory: (name: string) => Promise<void>;
  createTag: (name: string) => Promise<void>;
}

export const useKnowledgeStore = create<KnowledgeState & KnowledgeActions>()
  subscribeWithSelector(
    immer((set, get) => ({
      // åˆå§‹çŠ¶æ€
      documents: [],
      categories: [],
      tags: [],
      searchQuery: '',
      searchResults: [],
      filters: {
        category: [],
        tags: [],
        dateRange: null,
        author: [],
        fileType: []
      },
      selectedDocument: null,
      loading: {
        documents: false,
        search: false,
        upload: false
      },
      error: null,

      // æ–‡æ¡£ç®¡ç†
      loadDocuments: async (projectId: string) => {
        set((state) => {
          state.loading.documents = true;
          state.error = null;
        });

        try {
          const response = await fetch(`/api/projects/${projectId}/documents`);
          if (!response.ok) throw new Error('åŠ è½½æ–‡æ¡£å¤±è´¥');

          const documents = await response.json();

          set((state) => {
            state.documents = documents;
            state.loading.documents = false;
          });
        } catch (error) {
          set((state) => {
            state.error = error instanceof Error ? error.message : 'åŠ è½½æ–‡æ¡£å¤±è´¥';
            state.loading.documents = false;
          });
        }
      },

      createDocument: async (document: Partial<Document>) => {
        set((state) => {
          state.loading.upload = true;
          state.error = null;
        });

        try {
          const response = await fetch('/api/documents', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(document)
          });

          if (!response.ok) throw new Error('åˆ›å»ºæ–‡æ¡£å¤±è´¥');

          const newDocument = await response.json();

          set((state) => {
            state.documents.unshift(newDocument);
            state.loading.upload = false;
          });
        } catch (error) {
          set((state) => {
            state.error = error instanceof Error ? error.message : 'åˆ›å»ºæ–‡æ¡£å¤±è´¥';
            state.loading.upload = false;
          });
        }
      },

      updateDocument: async (documentId: string, updates: Partial<Document>) => {
        try {
          const response = await fetch(`/api/documents/${documentId}`, {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(updates)
          });

          if (!response.ok) throw new Error('æ›´æ–°æ–‡æ¡£å¤±è´¥');

          const updatedDocument = await response.json();

          set((state) => {
            const index = state.documents.findIndex(doc => doc.id === documentId);
            if (index !== -1) {
              state.documents[index] = updatedDocument;
            }

            // æ›´æ–°æœç´¢ç»“æœä¸­çš„æ–‡æ¡£
            const searchIndex = state.searchResults.findIndex(doc => doc.id === documentId);
            if (searchIndex !== -1) {
              state.searchResults[searchIndex] = updatedDocument;
            }
          });
        } catch (error) {
          set((state) => {
            state.error = error instanceof Error ? error.message : 'æ›´æ–°æ–‡æ¡£å¤±è´¥';
          });
        }
      },

      deleteDocument: async (documentId: string) => {
        try {
          const response = await fetch(`/api/documents/${documentId}`, {
            method: 'DELETE'
          });

          if (!response.ok) throw new Error('åˆ é™¤æ–‡æ¡£å¤±è´¥');

          set((state) => {
            state.documents = state.documents.filter(doc => doc.id !== documentId);
            state.searchResults = state.searchResults.filter(doc => doc.id !== documentId);

            if (state.selectedDocument === documentId) {
              state.selectedDocument = null;
            }
          });
        } catch (error) {
          set((state) => {
            state.error = error instanceof Error ? error.message : 'åˆ é™¤æ–‡æ¡£å¤±è´¥';
          });
        }
      },

      // æœç´¢åŠŸèƒ½
      search: async (query: string, filters?: Partial<SearchFilters>) => {
        set((state) => {
          state.loading.search = true;
          state.error = null;
          state.searchQuery = query;

          if (filters) {
            state.filters = { ...state.filters, ...filters };
          }
        });

        try {
          const searchParams = new URLSearchParams({
            q: query,
            ...Object.entries(get().filters).reduce((acc, [key, value]) => {
              if (Array.isArray(value) && value.length > 0) {
                acc[key] = value.join(',');
              } else if (value && typeof value === 'object' && 'start' in value) {
                if (value.start) acc[`${key}_start`] = value.start.toISOString();
                if (value.end) acc[`${key}_end`] = value.end.toISOString();
              }
              return acc;
            }, {} as Record<string, string>)
          });

          const response = await fetch(`/api/documents/search?${searchParams}`);
          if (!response.ok) throw new Error('æœç´¢å¤±è´¥');

          const results = await response.json();

          set((state) => {
            state.searchResults = results;
            state.loading.search = false;
          });
        } catch (error) {
          set((state) => {
            state.error = error instanceof Error ? error.message : 'æœç´¢å¤±è´¥';
            state.loading.search = false;
          });
        }
      },

      setSearchQuery: (query: string) => {
        set((state) => {
          state.searchQuery = query;
        });
      },

      setFilters: (filters: Partial<SearchFilters>) => {
        set((state) => {
          state.filters = { ...state.filters, ...filters };
        });
      },

      clearSearch: () => {
        set((state) => {
          state.searchQuery = '';
          state.searchResults = [];
          state.filters = {
            category: [],
            tags: [],
            dateRange: null,
            author: [],
            fileType: []
          };
        });
      },

      // æ–‡æ¡£æ“ä½œ
      selectDocument: (documentId: string | null) => {
        set((state) => {
          state.selectedDocument = documentId;
        });
      },

      incrementViewCount: async (documentId: string) => {
        try {
          await fetch(`/api/documents/${documentId}/view`, {
            method: 'POST'
          });

          set((state) => {
            const document = state.documents.find(doc => doc.id === documentId);
            if (document) {
              document.viewCount += 1;
            }

            const searchResult = state.searchResults.find(doc => doc.id === documentId);
            if (searchResult) {
              searchResult.viewCount += 1;
            }
          });
        } catch (error) {
          console.error('æ›´æ–°æµè§ˆæ¬¡æ•°å¤±è´¥:', error);
        }
      },

      incrementDownloadCount: async (documentId: string) => {
        try {
          await fetch(`/api/documents/${documentId}/download`, {
            method: 'POST'
          });

          set((state) => {
            const document = state.documents.find(doc => doc.id === documentId);
            if (document) {
              document.downloadCount += 1;
            }

            const searchResult = state.searchResults.find(doc => doc.id === documentId);
            if (searchResult) {
              searchResult.downloadCount += 1;
            }
          });
        } catch (error) {
          console.error('æ›´æ–°ä¸‹è½½æ¬¡æ•°å¤±è´¥:', error);
        }
      },

      // AIåŠŸèƒ½
      generateSummary: async (documentId: string) => {
        try {
          const response = await fetch(`/api/documents/${documentId}/ai/summary`, {
            method: 'POST'
          });

          if (!response.ok) throw new Error('ç”Ÿæˆæ‘˜è¦å¤±è´¥');

          const { summary } = await response.json();

          set((state) => {
            const document = state.documents.find(doc => doc.id === documentId);
            if (document) {
              document.aiSummary = summary;
            }

            const searchResult = state.searchResults.find(doc => doc.id === documentId);
            if (searchResult) {
              searchResult.aiSummary = summary;
            }
          });
        } catch (error) {
          set((state) => {
            state.error = error instanceof Error ? error.message : 'ç”Ÿæˆæ‘˜è¦å¤±è´¥';
          });
        }
      },

      generateTags: async (documentId: string) => {
        try {
          const response = await fetch(`/api/documents/${documentId}/ai/tags`, {
            method: 'POST'
          });

          if (!response.ok) throw new Error('ç”Ÿæˆæ ‡ç­¾å¤±è´¥');

          const { tags } = await response.json();

          set((state) => {
            const document = state.documents.find(doc => doc.id === documentId);
            if (document) {
              document.tags = [...new Set([...document.tags, ...tags])];
            }

            const searchResult = state.searchResults.find(doc => doc.id === documentId);
            if (searchResult) {
              searchResult.tags = [...new Set([...searchResult.tags, ...tags])];
            }
          });
        } catch (error) {
          set((state) => {
            state.error = error instanceof Error ? error.message : 'ç”Ÿæˆæ ‡ç­¾å¤±è´¥';
          });
        }
      },

      findSimilarDocuments: async (documentId: string) => {
        try {
          const response = await fetch(`/api/documents/${documentId}/similar`);
          if (!response.ok) throw new Error('æŸ¥æ‰¾ç›¸ä¼¼æ–‡æ¡£å¤±è´¥');

          return await response.json();
        } catch (error) {
          set((state) => {
            state.error = error instanceof Error ? error.message : 'æŸ¥æ‰¾ç›¸ä¼¼æ–‡æ¡£å¤±è´¥';
          });
          return [];
        }
      },

      // åˆ†ç±»å’Œæ ‡ç­¾
      loadCategories: async (projectId: string) => {
        try {
          const response = await fetch(`/api/projects/${projectId}/categories`);
          if (!response.ok) throw new Error('åŠ è½½åˆ†ç±»å¤±è´¥');

          const categories = await response.json();

          set((state) => {
            state.categories = categories;
          });
        } catch (error) {
          set((state) => {
            state.error = error instanceof Error ? error.message : 'åŠ è½½åˆ†ç±»å¤±è´¥';
          });
        }
      },

      loadTags: async (projectId: string) => {
        try {
          const response = await fetch(`/api/projects/${projectId}/tags`);
          if (!response.ok) throw new Error('åŠ è½½æ ‡ç­¾å¤±è´¥');

          const tags = await response.json();

          set((state) => {
            state.tags = tags;
          });
        } catch (error) {
          set((state) => {
            state.error = error instanceof Error ? error.message : 'åŠ è½½æ ‡ç­¾å¤±è´¥';
          });
        }
      },

      createCategory: async (name: string) => {
        try {
          const response = await fetch('/api/categories', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ name })
          });

          if (!response.ok) throw new Error('åˆ›å»ºåˆ†ç±»å¤±è´¥');

          set((state) => {
            if (!state.categories.includes(name)) {
              state.categories.push(name);
            }
          });
        } catch (error) {
          set((state) => {
            state.error = error instanceof Error ? error.message : 'åˆ›å»ºåˆ†ç±»å¤±è´¥';
          });
        }
      },

      createTag: async (name: string) => {
        try {
          const response = await fetch('/api/tags', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ name })
          });

          if (!response.ok) throw new Error('åˆ›å»ºæ ‡ç­¾å¤±è´¥');

          set((state) => {
            if (!state.tags.includes(name)) {
              state.tags.push(name);
            }
          });
        } catch (error) {
          set((state) => {
            state.error = error instanceof Error ? error.message : 'åˆ›å»ºæ ‡ç­¾å¤±è´¥';
          });
        }
      }
    }))
  )
);

// é€‰æ‹©å™¨
export const useDocuments = () => useKnowledgeStore(state => state.documents);
export const useSearchResults = () => useKnowledgeStore(state => state.searchResults);
export const useSelectedDocument = () => useKnowledgeStore(state => state.selectedDocument);
export const useKnowledgeLoading = () => useKnowledgeStore(state => state.loading);
export const useKnowledgeError = () => useKnowledgeStore(state => state.error);
export const useSearchQuery = () => useKnowledgeStore(state => state.searchQuery);
export const useSearchFilters = () => useKnowledgeStore(state => state.filters);
```

## 4. åç«¯APIè®¾è®¡

### 4.1 æ–‡æ¡£ç®¡ç†æ¥å£

```typescript
// pages/api/documents/index.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { getServerSession } from 'next-auth';
import { authOptions } from '../auth/[...nextauth]';
import { DocumentService } from '@/lib/services/DocumentService';
import { LangChainDocumentProcessor } from '@/lib/ai/DocumentProcessor';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getServerSession(req, res, authOptions);
  if (!session) {
    return res.status(401).json({ error: 'æœªæˆæƒè®¿é—®' });
  }

  const documentService = new DocumentService();
  const documentProcessor = new LangChainDocumentProcessor();

  switch (req.method) {
    case 'GET':
      try {
        const { projectId, category, tags, search } = req.query;
        const documents = await documentService.getDocuments({
          projectId: projectId as string,
          category: category as string,
          tags: tags ? (tags as string).split(',') : undefined,
          search: search as string,
          userId: session.user.id
        });

        res.status(200).json(documents);
      } catch (error) {
        res.status(500).json({ error: 'è·å–æ–‡æ¡£å¤±è´¥' });
      }
      break;

    case 'POST':
      try {
        const documentData = req.body;

        // åˆ›å»ºæ–‡æ¡£
        const document = await documentService.createDocument({
          ...documentData,
          authorId: session.user.id
        });

        // AIå¤„ç†ï¼šç”Ÿæˆæ‘˜è¦å’Œæ ‡ç­¾
        const aiEnhancements =
          await documentProcessor.processDocument(document);

        // æ›´æ–°æ–‡æ¡£
        const enhancedDocument = await documentService.updateDocument(
          document.id,
          aiEnhancements
        );

        res.status(201).json(enhancedDocument);
      } catch (error) {
        res.status(500).json({ error: 'åˆ›å»ºæ–‡æ¡£å¤±è´¥' });
      }
      break;

    default:
      res.setHeader('Allow', ['GET', 'POST']);
      res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}
```

### 4.2 æ™ºèƒ½æœç´¢æ¥å£

```typescript
// pages/api/documents/search.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { getServerSession } from 'next-auth';
import { authOptions } from '../auth/[...nextauth]';
import { LangChainSearchEngine } from '@/lib/ai/SearchEngine';
import { DocumentService } from '@/lib/services/DocumentService';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const session = await getServerSession(req, res, authOptions);
  if (!session) {
    return res.status(401).json({ error: 'æœªæˆæƒè®¿é—®' });
  }

  try {
    const { q: query, projectId, ...filters } = req.query;

    if (!query || typeof query !== 'string') {
      return res.status(400).json({ error: 'æœç´¢æŸ¥è¯¢ä¸èƒ½ä¸ºç©º' });
    }

    const searchEngine = new LangChainSearchEngine();
    const documentService = new DocumentService();

    // æ‰§è¡Œè¯­ä¹‰æœç´¢
    const searchResults = await searchEngine.semanticSearch({
      query,
      projectId: projectId as string,
      filters: {
        category: filters.category
          ? (filters.category as string).split(',')
          : [],
        tags: filters.tags ? (filters.tags as string).split(',') : [],
        author: filters.author ? (filters.author as string).split(',') : [],
        fileType: filters.fileType
          ? (filters.fileType as string).split(',')
          : [],
        dateRange: {
          start: filters.dateRange_start
            ? new Date(filters.dateRange_start as string)
            : null,
          end: filters.dateRange_end
            ? new Date(filters.dateRange_end as string)
            : null
        }
      },
      userId: session.user.id,
      limit: 50
    });

    // è®°å½•æœç´¢å†å²
    await documentService.recordSearchHistory({
      userId: session.user.id,
      query,
      projectId: projectId as string,
      resultCount: searchResults.length
    });

    res.status(200).json(searchResults);
  } catch (error) {
    console.error('æœç´¢å¤±è´¥:', error);
    res.status(500).json({ error: 'æœç´¢å¤±è´¥' });
  }
}
```

### 4.3 AIå¢å¼ºæ¥å£

```typescript
// pages/api/documents/[id]/ai/summary.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { getServerSession } from 'next-auth';
import { authOptions } from '../../../auth/[...nextauth]';
import { LangChainSummaryChain } from '@/lib/ai/chains/SummaryChain';
import { DocumentService } from '@/lib/services/DocumentService';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const session = await getServerSession(req, res, authOptions);
  if (!session) {
    return res.status(401).json({ error: 'æœªæˆæƒè®¿é—®' });
  }

  try {
    const { id: documentId } = req.query;

    const documentService = new DocumentService();
    const document = await documentService.getDocumentById(
      documentId as string,
      session.user.id
    );

    if (!document) {
      return res.status(404).json({ error: 'æ–‡æ¡£ä¸å­˜åœ¨' });
    }

    // ä½¿ç”¨LangChainç”Ÿæˆæ‘˜è¦
    const summaryChain = new LangChainSummaryChain();
    const summary = await summaryChain.generateSummary({
      content: document.content,
      title: document.title,
      context: {
        category: document.category,
        tags: document.tags
      }
    });

    // æ›´æ–°æ–‡æ¡£æ‘˜è¦
    await documentService.updateDocument(documentId as string, {
      aiSummary: summary
    });

    res.status(200).json({ summary });
  } catch (error) {
    console.error('ç”Ÿæˆæ‘˜è¦å¤±è´¥:', error);
    res.status(500).json({ error: 'ç”Ÿæˆæ‘˜è¦å¤±è´¥' });
  }
}
```

## 5. LangChainé›†æˆ

### 5.1 æ–‡æ¡£å¤„ç†é“¾

```typescript
// lib/ai/chains/DocumentProcessingChain.ts
import { BaseChain, ChainInputs } from 'langchain/chains';
import { OpenAI } from 'langchain/llms/openai';
import { PromptTemplate } from 'langchain/prompts';
import { LLMChain } from 'langchain/chains';
import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';
import { OpenAIEmbeddings } from 'langchain/embeddings/openai';
import { PineconeStore } from 'langchain/vectorstores/pinecone';

interface DocumentProcessingInput {
  content: string;
  title: string;
  metadata: {
    category?: string;
    author: string;
    fileType: string;
  };
}

interface DocumentProcessingOutput {
  summary: string;
  tags: string[];
  keyPoints: string[];
  embeddings: number[];
  chunks: Array<{
    content: string;
    metadata: any;
  }>;
}

export class DocumentProcessingChain extends BaseChain {
  private llm: OpenAI;
  private embeddings: OpenAIEmbeddings;
  private textSplitter: RecursiveCharacterTextSplitter;
  private summaryChain: LLMChain;
  private tagChain: LLMChain;
  private keyPointsChain: LLMChain;

  constructor() {
    super();

    this.llm = new OpenAI({
      temperature: 0.3,
      modelName: 'gpt-3.5-turbo'
    });

    this.embeddings = new OpenAIEmbeddings();

    this.textSplitter = new RecursiveCharacterTextSplitter({
      chunkSize: 1000,
      chunkOverlap: 200
    });

    // æ‘˜è¦ç”Ÿæˆé“¾
    const summaryPrompt = PromptTemplate.fromTemplate(`
      è¯·ä¸ºä»¥ä¸‹æ–‡æ¡£ç”Ÿæˆä¸€ä¸ªç®€æ´çš„æ‘˜è¦ï¼ˆä¸è¶…è¿‡200å­—ï¼‰ï¼š
      
      æ ‡é¢˜ï¼š{title}
      åˆ†ç±»ï¼š{category}
      å†…å®¹ï¼š{content}
      
      æ‘˜è¦ï¼š
    `);

    this.summaryChain = new LLMChain({
      llm: this.llm,
      prompt: summaryPrompt
    });

    // æ ‡ç­¾ç”Ÿæˆé“¾
    const tagPrompt = PromptTemplate.fromTemplate(`
      è¯·ä¸ºä»¥ä¸‹æ–‡æ¡£ç”Ÿæˆ5-8ä¸ªç›¸å…³æ ‡ç­¾ï¼Œæ ‡ç­¾åº”è¯¥ç®€æ´ä¸”å…·æœ‰ä»£è¡¨æ€§ï¼š
      
      æ ‡é¢˜ï¼š{title}
      åˆ†ç±»ï¼š{category}
      å†…å®¹ï¼š{content}
      
      è¯·ä»¥JSONæ•°ç»„æ ¼å¼è¿”å›æ ‡ç­¾ï¼š["æ ‡ç­¾1", "æ ‡ç­¾2", ...]
    `);

    this.tagChain = new LLMChain({
      llm: this.llm,
      prompt: tagPrompt
    });

    // å…³é”®ç‚¹æå–é“¾
    const keyPointsPrompt = PromptTemplate.fromTemplate(`
      è¯·ä»ä»¥ä¸‹æ–‡æ¡£ä¸­æå–3-5ä¸ªå…³é”®ç‚¹ï¼š
      
      æ ‡é¢˜ï¼š{title}
      å†…å®¹ï¼š{content}
      
      è¯·ä»¥JSONæ•°ç»„æ ¼å¼è¿”å›å…³é”®ç‚¹ï¼š["å…³é”®ç‚¹1", "å…³é”®ç‚¹2", ...]
    `);

    this.keyPointsChain = new LLMChain({
      llm: this.llm,
      prompt: keyPointsPrompt
    });
  }

  _chainType(): string {
    return 'document_processing_chain';
  }

  get inputKeys(): string[] {
    return ['content', 'title', 'metadata'];
  }

  get outputKeys(): string[] {
    return ['summary', 'tags', 'keyPoints', 'embeddings', 'chunks'];
  }

  async _call(
    values: DocumentProcessingInput
  ): Promise<DocumentProcessingOutput> {
    const { content, title, metadata } = values;

    try {
      // å¹¶è¡Œæ‰§è¡Œå¤šä¸ªAIä»»åŠ¡
      const [summaryResult, tagResult, keyPointsResult] = await Promise.all([
        this.summaryChain.call({
          title,
          category: metadata.category || 'æœªåˆ†ç±»',
          content: content.slice(0, 3000) // é™åˆ¶é•¿åº¦ä»¥æ§åˆ¶æˆæœ¬
        }),
        this.tagChain.call({
          title,
          category: metadata.category || 'æœªåˆ†ç±»',
          content: content.slice(0, 2000)
        }),
        this.keyPointsChain.call({
          title,
          content: content.slice(0, 2000)
        })
      ]);

      // è§£ææ ‡ç­¾å’Œå…³é”®ç‚¹
      let tags: string[] = [];
      let keyPoints: string[] = [];

      try {
        tags = JSON.parse(tagResult.text);
      } catch {
        // å¦‚æœè§£æå¤±è´¥ï¼Œå°è¯•ç®€å•çš„åˆ†å‰²
        tags = tagResult.text
          .split(',')
          .map((tag: string) => tag.trim())
          .filter(Boolean);
      }

      try {
        keyPoints = JSON.parse(keyPointsResult.text);
      } catch {
        keyPoints = keyPointsResult.text.split('\n').filter(Boolean);
      }

      // æ–‡æ¡£åˆ†å—
      const chunks = await this.textSplitter.createDocuments(
        [content],
        [{ title, ...metadata }]
      );

      // ç”ŸæˆåµŒå…¥å‘é‡
      const embeddings = await this.embeddings.embedQuery(content);

      return {
        summary: summaryResult.text.trim(),
        tags: tags.slice(0, 8), // é™åˆ¶æ ‡ç­¾æ•°é‡
        keyPoints: keyPoints.slice(0, 5), // é™åˆ¶å…³é”®ç‚¹æ•°é‡
        embeddings,
        chunks: chunks.map((chunk) => ({
          content: chunk.pageContent,
          metadata: chunk.metadata
        }))
      };
    } catch (error) {
      console.error('æ–‡æ¡£å¤„ç†å¤±è´¥:', error);
      throw new Error('æ–‡æ¡£å¤„ç†å¤±è´¥');
    }
  }
}
```

### 5.2 è¯­ä¹‰æœç´¢å¼•æ“

```typescript
// lib/ai/SearchEngine.ts
import { OpenAIEmbeddings } from 'langchain/embeddings/openai';
import { PineconeStore } from 'langchain/vectorstores/pinecone';
import { OpenAI } from 'langchain/llms/openai';
import { PromptTemplate } from 'langchain/prompts';
import { LLMChain } from 'langchain/chains';
import { DocumentService } from '@/lib/services/DocumentService';

interface SearchFilters {
  category: string[];
  tags: string[];
  author: string[];
  fileType: string[];
  dateRange: {
    start: Date | null;
    end: Date | null;
  };
}

interface SearchOptions {
  query: string;
  projectId: string;
  filters: SearchFilters;
  userId: string;
  limit: number;
}

interface SearchResult {
  id: string;
  title: string;
  description?: string;
  content: string;
  relevanceScore: number;
  highlights: string[];
  metadata: any;
}

export class LangChainSearchEngine {
  private embeddings: OpenAIEmbeddings;
  private vectorStore: PineconeStore;
  private llm: OpenAI;
  private queryEnhancementChain: LLMChain;
  private documentService: DocumentService;

  constructor() {
    this.embeddings = new OpenAIEmbeddings();
    this.llm = new OpenAI({ temperature: 0.1 });
    this.documentService = new DocumentService();

    // æŸ¥è¯¢å¢å¼ºé“¾
    const queryEnhancementPrompt = PromptTemplate.fromTemplate(`
      ç”¨æˆ·æœç´¢æŸ¥è¯¢ï¼š{query}
      
      è¯·åˆ†æè¿™ä¸ªæŸ¥è¯¢çš„æ„å›¾ï¼Œå¹¶ç”Ÿæˆ3-5ä¸ªç›¸å…³çš„æœç´¢å…³é”®è¯æˆ–çŸ­è¯­ï¼Œè¿™äº›å…³é”®è¯åº”è¯¥èƒ½å¸®åŠ©æ‰¾åˆ°æ›´ç›¸å…³çš„æ–‡æ¡£ã€‚
      
      åŸæŸ¥è¯¢ï¼š{query}
      å¢å¼ºå…³é”®è¯ï¼š
    `);

    this.queryEnhancementChain = new LLMChain({
      llm: this.llm,
      prompt: queryEnhancementPrompt
    });
  }

  async semanticSearch(options: SearchOptions): Promise<SearchResult[]> {
    const { query, projectId, filters, userId, limit } = options;

    try {
      // 1. æŸ¥è¯¢å¢å¼º
      const enhancedQuery = await this.enhanceQuery(query);

      // 2. ç”ŸæˆæŸ¥è¯¢å‘é‡
      const queryEmbedding = await this.embeddings.embedQuery(enhancedQuery);

      // 3. å‘é‡æœç´¢
      const vectorResults = await this.vectorStore.similaritySearchWithScore(
        enhancedQuery,
        limit * 2 // è·å–æ›´å¤šç»“æœç”¨äºåç»­è¿‡æ»¤
      );

      // 4. åº”ç”¨è¿‡æ»¤å™¨
      const filteredResults = await this.applyFilters(
        vectorResults,
        filters,
        projectId,
        userId
      );

      // 5. é‡æ–°æ’åºå’Œè¯„åˆ†
      const rankedResults = await this.rankResults(
        filteredResults,
        query,
        enhancedQuery
      );

      // 6. ç”Ÿæˆé«˜äº®
      const resultsWithHighlights = await this.generateHighlights(
        rankedResults.slice(0, limit),
        query
      );

      return resultsWithHighlights;
    } catch (error) {
      console.error('è¯­ä¹‰æœç´¢å¤±è´¥:', error);
      throw new Error('æœç´¢å¤±è´¥');
    }
  }

  private async enhanceQuery(query: string): Promise<string> {
    try {
      const result = await this.queryEnhancementChain.call({ query });
      return `${query} ${result.text}`.trim();
    } catch (error) {
      console.error('æŸ¥è¯¢å¢å¼ºå¤±è´¥:', error);
      return query;
    }
  }

  private async applyFilters(
    vectorResults: Array<[any, number]>,
    filters: SearchFilters,
    projectId: string,
    userId: string
  ): Promise<Array<[any, number]>> {
    // è·å–æ–‡æ¡£è¯¦ç»†ä¿¡æ¯å¹¶åº”ç”¨è¿‡æ»¤å™¨
    const documentIds = vectorResults.map(([doc]) => doc.metadata.documentId);
    const documents = await this.documentService.getDocumentsByIds(
      documentIds,
      userId
    );

    const documentMap = new Map(documents.map((doc) => [doc.id, doc]));

    return vectorResults.filter(([doc, score]) => {
      const document = documentMap.get(doc.metadata.documentId);
      if (!document || document.projectId !== projectId) return false;

      // åº”ç”¨åˆ†ç±»è¿‡æ»¤
      if (
        filters.category.length > 0 &&
        !filters.category.includes(document.category)
      ) {
        return false;
      }

      // åº”ç”¨æ ‡ç­¾è¿‡æ»¤
      if (filters.tags.length > 0) {
        const hasMatchingTag = filters.tags.some((tag) =>
          document.tags.includes(tag)
        );
        if (!hasMatchingTag) return false;
      }

      // åº”ç”¨ä½œè€…è¿‡æ»¤
      if (
        filters.author.length > 0 &&
        !filters.author.includes(document.authorId)
      ) {
        return false;
      }

      // åº”ç”¨æ–‡ä»¶ç±»å‹è¿‡æ»¤
      if (
        filters.fileType.length > 0 &&
        !filters.fileType.includes(document.fileType)
      ) {
        return false;
      }

      // åº”ç”¨æ—¥æœŸèŒƒå›´è¿‡æ»¤
      if (
        filters.dateRange.start &&
        document.createdAt < filters.dateRange.start
      ) {
        return false;
      }
      if (filters.dateRange.end && document.createdAt > filters.dateRange.end) {
        return false;
      }

      return true;
    });
  }

  private async rankResults(
    results: Array<[any, number]>,
    originalQuery: string,
    enhancedQuery: string
  ): Promise<SearchResult[]> {
    const documentIds = results.map(([doc]) => doc.metadata.documentId);
    const documents = await this.documentService.getDocumentsByIds(documentIds);
    const documentMap = new Map(documents.map((doc) => [doc.id, doc]));

    return results
      .map(([doc, vectorScore]) => {
        const document = documentMap.get(doc.metadata.documentId);
        if (!document) return null;

        // è®¡ç®—ç»¼åˆç›¸å…³æ€§è¯„åˆ†
        const titleMatch = this.calculateTextMatch(
          originalQuery,
          document.title
        );
        const contentMatch = this.calculateTextMatch(
          originalQuery,
          doc.pageContent
        );
        const tagMatch = this.calculateTagMatch(originalQuery, document.tags);

        // ç»¼åˆè¯„åˆ†
        const relevanceScore =
          vectorScore * 0.4 +
          titleMatch * 0.3 +
          contentMatch * 0.2 +
          tagMatch * 0.1;

        return {
          id: document.id,
          title: document.title,
          description: document.description,
          content: doc.pageContent,
          relevanceScore,
          highlights: [],
          metadata: {
            ...document,
            chunkIndex: doc.metadata.chunkIndex
          }
        };
      })
      .filter(Boolean)
      .sort((a, b) => b!.relevanceScore - a!.relevanceScore) as SearchResult[];
  }

  private calculateTextMatch(query: string, text: string): number {
    const queryWords = query.toLowerCase().split(/\s+/);
    const textWords = text.toLowerCase().split(/\s+/);

    let matches = 0;
    queryWords.forEach((queryWord) => {
      if (textWords.some((textWord) => textWord.includes(queryWord))) {
        matches++;
      }
    });

    return matches / queryWords.length;
  }

  private calculateTagMatch(query: string, tags: string[]): number {
    const queryLower = query.toLowerCase();
    const matchingTags = tags.filter(
      (tag) =>
        tag.toLowerCase().includes(queryLower) ||
        queryLower.includes(tag.toLowerCase())
    );

    return matchingTags.length / Math.max(tags.length, 1);
  }

  private async generateHighlights(
    results: SearchResult[],
    query: string
  ): Promise<SearchResult[]> {
    const queryWords = query.toLowerCase().split(/\s+/);

    return results.map((result) => {
      const highlights: string[] = [];

      // åœ¨æ ‡é¢˜ä¸­æŸ¥æ‰¾é«˜äº®
      queryWords.forEach((word) => {
        if (result.title.toLowerCase().includes(word)) {
          highlights.push(word);
        }
      });

      // åœ¨å†…å®¹ä¸­æŸ¥æ‰¾é«˜äº®ç‰‡æ®µ
      const contentHighlights = this.extractHighlightSnippets(
        result.content,
        queryWords
      );
      highlights.push(...contentHighlights);

      return {
        ...result,
        highlights: [...new Set(highlights)] // å»é‡
      };
    });
  }

  private extractHighlightSnippets(
    content: string,
    queryWords: string[]
  ): string[] {
    const snippets: string[] = [];
    const sentences = content.split(/[.!?]+/);

    sentences.forEach((sentence) => {
      const sentenceLower = sentence.toLowerCase();
      const hasMatch = queryWords.some((word) => sentenceLower.includes(word));

      if (hasMatch && sentence.trim().length > 10) {
        snippets.push(sentence.trim().slice(0, 150));
      }
    });

    return snippets.slice(0, 3); // æœ€å¤šè¿”å›3ä¸ªç‰‡æ®µ
  }
}
```

## 6. LangGraphå·¥ä½œæµå¼•æ“

### 6.1 çŸ¥è¯†å›¾è°±æ„å»ºå·¥ä½œæµ

```typescript
// lib/ai/workflows/KnowledgeGraphWorkflow.ts
import { StateGraph, END } from '@langchain/langgraph';
import { BaseMessage } from '@langchain/core/messages';
import { OpenAI } from 'langchain/llms/openai';
import { PromptTemplate } from 'langchain/prompts';

interface KnowledgeGraphState {
  documents: Array<{
    id: string;
    title: string;
    content: string;
    category: string;
    tags: string[];
  }>;
  entities: Array<{
    name: string;
    type: string;
    description: string;
    documentIds: string[];
  }>;
  relationships: Array<{
    source: string;
    target: string;
    type: string;
    weight: number;
    description: string;
  }>;
  currentStep: string;
  error?: string;
}

export class KnowledgeGraphWorkflow {
  private llm: OpenAI;
  private workflow: StateGraph<KnowledgeGraphState>;

  constructor() {
    this.llm = new OpenAI({ temperature: 0.1 });
    this.workflow = this.createWorkflow();
  }

  private createWorkflow(): StateGraph<KnowledgeGraphState> {
    const workflow = new StateGraph<KnowledgeGraphState>({
      channels: {
        documents: {
          reducer: (x, y) => y ?? x,
          default: () => []
        },
        entities: {
          reducer: (x, y) => y ?? x,
          default: () => []
        },
        relationships: {
          reducer: (x, y) => y ?? x,
          default: () => []
        },
        currentStep: {
          reducer: (x, y) => y ?? x,
          default: () => 'start'
        },
        error: {
          reducer: (x, y) => y ?? x
        }
      }
    });

    // æ·»åŠ èŠ‚ç‚¹
    workflow.addNode('extract_entities', this.extractEntities.bind(this));
    workflow.addNode('find_relationships', this.findRelationships.bind(this));
    workflow.addNode('validate_graph', this.validateGraph.bind(this));
    workflow.addNode('optimize_graph', this.optimizeGraph.bind(this));

    // å®šä¹‰è¾¹
    workflow.addEdge('__start__', 'extract_entities');
    workflow.addEdge('extract_entities', 'find_relationships');
    workflow.addEdge('find_relationships', 'validate_graph');
    workflow.addEdge('validate_graph', 'optimize_graph');
    workflow.addEdge('optimize_graph', '__end__');

    return workflow;
  }

  private async extractEntities(
    state: KnowledgeGraphState
  ): Promise<Partial<KnowledgeGraphState>> {
    try {
      const entityPrompt = PromptTemplate.fromTemplate(`
        ä»ä»¥ä¸‹æ–‡æ¡£ä¸­æå–å…³é”®å®ä½“ï¼ˆäººç‰©ã€æ¦‚å¿µã€æŠ€æœ¯ã€é¡¹ç›®ç­‰ï¼‰ï¼š
        
        æ ‡é¢˜ï¼š{title}
        åˆ†ç±»ï¼š{category}
        å†…å®¹ï¼š{content}
        
        è¯·ä»¥JSONæ ¼å¼è¿”å›å®ä½“åˆ—è¡¨ï¼š
        [
          {
            "name": "å®ä½“åç§°",
            "type": "å®ä½“ç±»å‹ï¼ˆperson/concept/technology/project/otherï¼‰",
            "description": "ç®€çŸ­æè¿°"
          }
        ]
      `);

      const allEntities = [];

      for (const doc of state.documents) {
        const result = await this.llm.call(
          await entityPrompt.format({
            title: doc.title,
            category: doc.category,
            content: doc.content.slice(0, 2000) // é™åˆ¶é•¿åº¦
          })
        );

        try {
          const entities = JSON.parse(result);
          entities.forEach((entity: any) => {
            const existingEntity = allEntities.find(
              (e) => e.name === entity.name
            );
            if (existingEntity) {
              existingEntity.documentIds.push(doc.id);
            } else {
              allEntities.push({
                ...entity,
                documentIds: [doc.id]
              });
            }
          });
        } catch (error) {
          console.error('è§£æå®ä½“å¤±è´¥:', error);
        }
      }

      return {
        entities: allEntities,
        currentStep: 'extract_entities_completed'
      };
    } catch (error) {
      return {
        error: `å®ä½“æå–å¤±è´¥: ${error.message}`,
        currentStep: 'error'
      };
    }
  }

  private async findRelationships(
    state: KnowledgeGraphState
  ): Promise<Partial<KnowledgeGraphState>> {
    try {
      const relationshipPrompt = PromptTemplate.fromTemplate(`
        åˆ†æä»¥ä¸‹å®ä½“ä¹‹é—´çš„å…³ç³»ï¼š
        
        å®ä½“åˆ—è¡¨ï¼š{entities}
        
        è¯·è¯†åˆ«å®ä½“ä¹‹é—´çš„å…³ç³»ï¼Œå¹¶ä»¥JSONæ ¼å¼è¿”å›ï¼š
        [
          {
            "source": "æºå®ä½“åç§°",
            "target": "ç›®æ ‡å®ä½“åç§°",
            "type": "å…³ç³»ç±»å‹ï¼ˆrelated_to/part_of/depends_on/similar_to/collaborates_withï¼‰",
            "weight": å…³ç³»å¼ºåº¦ï¼ˆ0-1ä¹‹é—´çš„æ•°å€¼ï¼‰,
            "description": "å…³ç³»æè¿°"
          }
        ]
      `);

      const entityNames = state.entities.map((e) => e.name).join(', ');
      const result = await this.llm.call(
        await relationshipPrompt.format({
          entities: entityNames
        })
      );

      let relationships = [];
      try {
        relationships = JSON.parse(result);
      } catch (error) {
        console.error('è§£æå…³ç³»å¤±è´¥:', error);
      }

      return {
        relationships,
        currentStep: 'find_relationships_completed'
      };
    } catch (error) {
      return {
        error: `å…³ç³»å‘ç°å¤±è´¥: ${error.message}`,
        currentStep: 'error'
      };
    }
  }

  private async validateGraph(
    state: KnowledgeGraphState
  ): Promise<Partial<KnowledgeGraphState>> {
    try {
      // éªŒè¯å®ä½“å’Œå…³ç³»çš„æœ‰æ•ˆæ€§
      const validEntities = state.entities.filter(
        (entity) => entity.name && entity.type && entity.documentIds.length > 0
      );

      const entityNames = new Set(validEntities.map((e) => e.name));
      const validRelationships = state.relationships.filter(
        (rel) =>
          entityNames.has(rel.source) &&
          entityNames.has(rel.target) &&
          rel.source !== rel.target &&
          rel.weight > 0.1 // è¿‡æ»¤å¼±å…³ç³»
      );

      return {
        entities: validEntities,
        relationships: validRelationships,
        currentStep: 'validate_graph_completed'
      };
    } catch (error) {
      return {
        error: `å›¾è°±éªŒè¯å¤±è´¥: ${error.message}`,
        currentStep: 'error'
      };
    }
  }

  private async optimizeGraph(
    state: KnowledgeGraphState
  ): Promise<Partial<KnowledgeGraphState>> {
    try {
      // ä¼˜åŒ–å›¾è°±ç»“æ„
      const optimizedRelationships = state.relationships
        .sort((a, b) => b.weight - a.weight)
        .slice(0, 100); // é™åˆ¶å…³ç³»æ•°é‡

      // ç§»é™¤å­¤ç«‹èŠ‚ç‚¹
      const connectedEntityNames = new Set();
      optimizedRelationships.forEach((rel) => {
        connectedEntityNames.add(rel.source);
        connectedEntityNames.add(rel.target);
      });

      const optimizedEntities = state.entities.filter((entity) =>
        connectedEntityNames.has(entity.name)
      );

      return {
        entities: optimizedEntities,
        relationships: optimizedRelationships,
        currentStep: 'optimize_graph_completed'
      };
    } catch (error) {
      return {
        error: `å›¾è°±ä¼˜åŒ–å¤±è´¥: ${error.message}`,
        currentStep: 'error'
      };
    }
  }

  async buildKnowledgeGraph(documents: any[]): Promise<{
    entities: any[];
    relationships: any[];
  }> {
    const initialState: KnowledgeGraphState = {
      documents,
      entities: [],
      relationships: [],
      currentStep: 'start'
    };

    const result = await this.workflow.invoke(initialState);

    if (result.error) {
      throw new Error(result.error);
    }

    return {
      entities: result.entities,
      relationships: result.relationships
    };
  }
}
```

## 7. æ•°æ®åº“è®¾è®¡

### 7.1 æ•°æ®è¡¨ç»“æ„

```sql
-- æ–‡æ¡£è¡¨
CREATE TABLE documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title VARCHAR(255) NOT NULL,
  description TEXT,
  content TEXT NOT NULL,
  category VARCHAR(100),
  file_type VARCHAR(50),
  file_size BIGINT,
  file_path VARCHAR(500),
  project_id UUID NOT NULL REFERENCES projects(id),
  author_id UUID NOT NULL REFERENCES users(id),
  ai_summary TEXT,
  view_count INTEGER DEFAULT 0,
  download_count INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  deleted_at TIMESTAMP WITH TIME ZONE
);

-- æ–‡æ¡£æ ‡ç­¾è¡¨
CREATE TABLE document_tags (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
  tag_name VARCHAR(100) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- æ–‡æ¡£åˆ†å—è¡¨ï¼ˆç”¨äºå‘é‡æœç´¢ï¼‰
CREATE TABLE document_chunks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
  chunk_index INTEGER NOT NULL,
  content TEXT NOT NULL,
  embedding VECTOR(1536), -- OpenAI embeddingç»´åº¦
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- æœç´¢å†å²è¡¨
CREATE TABLE search_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id),
  project_id UUID REFERENCES projects(id),
  query TEXT NOT NULL,
  result_count INTEGER,
  filters JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- çŸ¥è¯†å›¾è°±å®ä½“è¡¨
CREATE TABLE knowledge_entities (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  type VARCHAR(50) NOT NULL, -- person, concept, technology, project, other
  description TEXT,
  project_id UUID NOT NULL REFERENCES projects(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- çŸ¥è¯†å›¾è°±å…³ç³»è¡¨
CREATE TABLE knowledge_relationships (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  source_entity_id UUID NOT NULL REFERENCES knowledge_entities(id) ON DELETE CASCADE,
  target_entity_id UUID NOT NULL REFERENCES knowledge_entities(id) ON DELETE CASCADE,
  relationship_type VARCHAR(50) NOT NULL, -- related_to, part_of, depends_on, similar_to, collaborates_with
  weight DECIMAL(3,2) DEFAULT 0.5,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- å®ä½“æ–‡æ¡£å…³è”è¡¨
CREATE TABLE entity_documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  entity_id UUID NOT NULL REFERENCES knowledge_entities(id) ON DELETE CASCADE,
  document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
  relevance_score DECIMAL(3,2) DEFAULT 0.5,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- æ–‡æ¡£åˆ†äº«è¡¨
CREATE TABLE document_shares (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
  shared_by UUID NOT NULL REFERENCES users(id),
  shared_with UUID REFERENCES users(id),
  share_token VARCHAR(255) UNIQUE,
  permissions JSONB DEFAULT '{"read": true, "download": false}',
  expires_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- æ–‡æ¡£è¯„è®ºè¡¨
CREATE TABLE document_comments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id),
  parent_id UUID REFERENCES document_comments(id),
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  deleted_at TIMESTAMP WITH TIME ZONE
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_documents_project_id ON documents(project_id);
CREATE INDEX idx_documents_author_id ON documents(author_id);
CREATE INDEX idx_documents_category ON documents(category);
CREATE INDEX idx_documents_created_at ON documents(created_at);
CREATE INDEX idx_document_tags_document_id ON document_tags(document_id);
CREATE INDEX idx_document_tags_tag_name ON document_tags(tag_name);
CREATE INDEX idx_document_chunks_document_id ON document_chunks(document_id);
CREATE INDEX idx_search_history_user_id ON search_history(user_id);
CREATE INDEX idx_knowledge_entities_project_id ON knowledge_entities(project_id);
CREATE INDEX idx_knowledge_entities_type ON knowledge_entities(type);
CREATE INDEX idx_entity_documents_entity_id ON entity_documents(entity_id);
CREATE INDEX idx_entity_documents_document_id ON entity_documents(document_id);

-- å…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_documents_content_fts ON documents USING gin(to_tsvector('chinese', content));
CREATE INDEX idx_documents_title_fts ON documents USING gin(to_tsvector('chinese', title));
```

### 7.2 æ•°æ®è®¿é—®å±‚

```typescript
// lib/dao/DocumentDAO.ts
import { Pool } from 'pg';
import { Document, DocumentFilters, SearchResult } from '@/types/knowledge';

export class DocumentDAO {
  private pool: Pool;

  constructor(pool: Pool) {
    this.pool = pool;
  }

  async createDocument(document: Partial<Document>): Promise<Document> {
    const client = await this.pool.connect();

    try {
      await client.query('BEGIN');

      // æ’å…¥æ–‡æ¡£
      const documentResult = await client.query(
        `
        INSERT INTO documents (
          title, description, content, category, file_type, file_size, 
          file_path, project_id, author_id, ai_summary
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING *
      `,
        [
          document.title,
          document.description,
          document.content,
          document.category,
          document.fileType,
          document.fileSize,
          document.filePath,
          document.projectId,
          document.authorId,
          document.aiSummary
        ]
      );

      const newDocument = documentResult.rows[0];

      // æ’å…¥æ ‡ç­¾
      if (document.tags && document.tags.length > 0) {
        for (const tag of document.tags) {
          await client.query(
            `
            INSERT INTO document_tags (document_id, tag_name)
            VALUES ($1, $2)
          `,
            [newDocument.id, tag]
          );
        }
      }

      await client.query('COMMIT');

      return await this.getDocumentById(newDocument.id);
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async getDocumentById(
    documentId: string,
    userId?: string
  ): Promise<Document | null> {
    const result = await this.pool.query(
      `
      SELECT 
        d.*,
        u.name as author_name,
        u.avatar as author_avatar,
        ARRAY_AGG(dt.tag_name) FILTER (WHERE dt.tag_name IS NOT NULL) as tags
      FROM documents d
      LEFT JOIN users u ON d.author_id = u.id
      LEFT JOIN document_tags dt ON d.id = dt.document_id
      WHERE d.id = $1 AND d.deleted_at IS NULL
      GROUP BY d.id, u.name, u.avatar
    `,
      [documentId]
    );

    if (result.rows.length === 0) return null;

    const doc = result.rows[0];

    // å¢åŠ æµè§ˆæ¬¡æ•°
    if (userId) {
      await this.incrementViewCount(documentId);
    }

    return this.mapRowToDocument(doc);
  }

  async getDocuments(filters: DocumentFilters): Promise<Document[]> {
    let query = `
      SELECT 
        d.*,
        u.name as author_name,
        u.avatar as author_avatar,
        ARRAY_AGG(DISTINCT dt.tag_name) FILTER (WHERE dt.tag_name IS NOT NULL) as tags
      FROM documents d
      LEFT JOIN users u ON d.author_id = u.id
      LEFT JOIN document_tags dt ON d.id = dt.document_id
      WHERE d.deleted_at IS NULL
    `;

    const params: any[] = [];
    let paramIndex = 1;

    if (filters.projectId) {
      query += ` AND d.project_id = $${paramIndex}`;
      params.push(filters.projectId);
      paramIndex++;
    }

    if (filters.category) {
      query += ` AND d.category = $${paramIndex}`;
      params.push(filters.category);
      paramIndex++;
    }

    if (filters.authorId) {
      query += ` AND d.author_id = $${paramIndex}`;
      params.push(filters.authorId);
      paramIndex++;
    }

    if (filters.search) {
      query += ` AND (
        to_tsvector('chinese', d.title) @@ plainto_tsquery('chinese', $${paramIndex})
        OR to_tsvector('chinese', d.content) @@ plainto_tsquery('chinese', $${paramIndex})
      )`;
      params.push(filters.search);
      paramIndex++;
    }

    query += ` GROUP BY d.id, u.name, u.avatar`;

    // æ ‡ç­¾è¿‡æ»¤ï¼ˆéœ€è¦åœ¨GROUP BYä¹‹åï¼‰
    if (filters.tags && filters.tags.length > 0) {
      query += ` HAVING ARRAY_AGG(DISTINCT dt.tag_name) && $${paramIndex}`;
      params.push(filters.tags);
      paramIndex++;
    }

    query += ` ORDER BY d.updated_at DESC`;

    if (filters.limit) {
      query += ` LIMIT $${paramIndex}`;
      params.push(filters.limit);
      paramIndex++;
    }

    if (filters.offset) {
      query += ` OFFSET $${paramIndex}`;
      params.push(filters.offset);
    }

    const result = await this.pool.query(query, params);

    return result.rows.map((row) => this.mapRowToDocument(row));
  }

  async updateDocument(
    documentId: string,
    updates: Partial<Document>
  ): Promise<Document> {
    const client = await this.pool.connect();

    try {
      await client.query('BEGIN');

      // æ›´æ–°æ–‡æ¡£åŸºæœ¬ä¿¡æ¯
      const updateFields = [];
      const params = [];
      let paramIndex = 1;

      if (updates.title !== undefined) {
        updateFields.push(`title = $${paramIndex}`);
        params.push(updates.title);
        paramIndex++;
      }

      if (updates.description !== undefined) {
        updateFields.push(`description = $${paramIndex}`);
        params.push(updates.description);
        paramIndex++;
      }

      if (updates.content !== undefined) {
        updateFields.push(`content = $${paramIndex}`);
        params.push(updates.content);
        paramIndex++;
      }

      if (updates.category !== undefined) {
        updateFields.push(`category = $${paramIndex}`);
        params.push(updates.category);
        paramIndex++;
      }

      if (updates.aiSummary !== undefined) {
        updateFields.push(`ai_summary = $${paramIndex}`);
        params.push(updates.aiSummary);
        paramIndex++;
      }

      updateFields.push(`updated_at = NOW()`);

      if (updateFields.length > 1) {
        // é™¤äº†updated_atä¹‹å¤–è¿˜æœ‰å…¶ä»–å­—æ®µ
        params.push(documentId);
        await client.query(
          `
          UPDATE documents 
          SET ${updateFields.join(', ')}
          WHERE id = $${paramIndex}
        `,
          params
        );
      }

      // æ›´æ–°æ ‡ç­¾
      if (updates.tags !== undefined) {
        // åˆ é™¤ç°æœ‰æ ‡ç­¾
        await client.query('DELETE FROM document_tags WHERE document_id = $1', [
          documentId
        ]);

        // æ’å…¥æ–°æ ‡ç­¾
        for (const tag of updates.tags) {
          await client.query(
            'INSERT INTO document_tags (document_id, tag_name) VALUES ($1, $2)',
            [documentId, tag]
          );
        }
      }

      await client.query('COMMIT');

      return await this.getDocumentById(documentId);
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async deleteDocument(documentId: string): Promise<void> {
    await this.pool.query(
      'UPDATE documents SET deleted_at = NOW() WHERE id = $1',
      [documentId]
    );
  }

  async incrementViewCount(documentId: string): Promise<void> {
    await this.pool.query(
      'UPDATE documents SET view_count = view_count + 1 WHERE id = $1',
      [documentId]
    );
  }

  async incrementDownloadCount(documentId: string): Promise<void> {
    await this.pool.query(
      'UPDATE documents SET download_count = download_count + 1 WHERE id = $1',
      [documentId]
    );
  }

  async recordSearchHistory(data: {
    userId: string;
    query: string;
    projectId?: string;
    resultCount: number;
    filters?: any;
  }): Promise<void> {
    await this.pool.query(
      `
      INSERT INTO search_history (user_id, project_id, query, result_count, filters)
      VALUES ($1, $2, $3, $4, $5)
    `,
      [
        data.userId,
        data.projectId,
        data.query,
        data.resultCount,
        JSON.stringify(data.filters || {})
      ]
    );
  }

  private mapRowToDocument(row: any): Document {
    return {
      id: row.id,
      title: row.title,
      description: row.description,
      content: row.content,
      category: row.category,
      tags: row.tags || [],
      author: {
        id: row.author_id,
        name: row.author_name,
        avatar: row.author_avatar
      },
      fileType: row.file_type,
      fileSize: row.file_size,
      filePath: row.file_path,
      projectId: row.project_id,
      aiSummary: row.ai_summary,
      viewCount: row.view_count,
      downloadCount: row.download_count,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };
  }
}
```

## 8. æ€§èƒ½ä¼˜åŒ–

### 8.1 å‰ç«¯æ€§èƒ½ä¼˜åŒ–

- **è™šæ‹ŸåŒ–åˆ—è¡¨**: ä½¿ç”¨react-windowå¤„ç†å¤§é‡æ–‡æ¡£åˆ—è¡¨
- **æ‡’åŠ è½½**: æ–‡æ¡£å†…å®¹å’Œå›¾ç‰‡çš„æ‡’åŠ è½½
- **ç¼“å­˜ç­–ç•¥**: React Queryç¼“å­˜APIå“åº”
- **ä»£ç åˆ†å‰²**: æŒ‰é¡µé¢å’ŒåŠŸèƒ½æ¨¡å—åˆ†å‰²ä»£ç 
- **é¢„åŠ è½½**: é¢„åŠ è½½ç”¨æˆ·å¯èƒ½è®¿é—®çš„æ–‡æ¡£

### 8.2 åç«¯æ€§èƒ½ä¼˜åŒ–

- **æ•°æ®åº“ä¼˜åŒ–**: åˆç†çš„ç´¢å¼•è®¾è®¡å’ŒæŸ¥è¯¢ä¼˜åŒ–
- **Redisç¼“å­˜**: ç¼“å­˜çƒ­é—¨æ–‡æ¡£å’Œæœç´¢ç»“æœ
- **å‘é‡æ•°æ®åº“**: ä½¿ç”¨Pineconeä¼˜åŒ–è¯­ä¹‰æœç´¢æ€§èƒ½
- **CDN**: æ–‡æ¡£æ–‡ä»¶çš„CDNåˆ†å‘
- **é™æµ**: APIè¯·æ±‚é™æµå’Œé˜²æŠ¤

## 9. é”™è¯¯å¤„ç†å’Œç›‘æ§

### 9.1 é”™è¯¯å¤„ç†ç­–ç•¥

- **å‰ç«¯é”™è¯¯è¾¹ç•Œ**: Reacté”™è¯¯è¾¹ç•Œç»„ä»¶
- **APIé”™è¯¯å¤„ç†**: ç»Ÿä¸€çš„é”™è¯¯å“åº”æ ¼å¼
- **ç”¨æˆ·å‹å¥½æç¤º**: æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯å±•ç¤º
- **é‡è¯•æœºåˆ¶**: ç½‘ç»œè¯·æ±‚çš„è‡ªåŠ¨é‡è¯•

### 9.2 ç›‘æ§æŒ‡æ ‡

- **æ€§èƒ½ç›‘æ§**: é¡µé¢åŠ è½½æ—¶é—´ã€APIå“åº”æ—¶é—´
- **ç”¨æˆ·è¡Œä¸º**: æœç´¢æŸ¥è¯¢ã€æ–‡æ¡£è®¿é—®ç»Ÿè®¡
- **AIæœåŠ¡ç›‘æ§**: LangChainè°ƒç”¨æˆåŠŸç‡å’Œå»¶è¿Ÿ
- **é”™è¯¯ç›‘æ§**: é”™è¯¯ç‡å’Œé”™è¯¯ç±»å‹ç»Ÿè®¡

## 10. æµ‹è¯•ç­–ç•¥

### 10.1 å‰ç«¯æµ‹è¯•

- **ç»„ä»¶æµ‹è¯•**: Jest + React Testing Library
- **é›†æˆæµ‹è¯•**: APIé›†æˆæµ‹è¯•
- **E2Eæµ‹è¯•**: Playwrightç«¯åˆ°ç«¯æµ‹è¯•
- **æ€§èƒ½æµ‹è¯•**: Lighthouseæ€§èƒ½æµ‹è¯•

### 10.2 åç«¯æµ‹è¯•

- **å•å…ƒæµ‹è¯•**: APIå‡½æ•°å’ŒæœåŠ¡ç±»æµ‹è¯•
- **é›†æˆæµ‹è¯•**: æ•°æ®åº“å’Œå¤–éƒ¨æœåŠ¡é›†æˆæµ‹è¯•
- **AIåŠŸèƒ½æµ‹è¯•**: LangChainé“¾å’Œå·¥ä½œæµæµ‹è¯•
- **è´Ÿè½½æµ‹è¯•**: é«˜å¹¶å‘åœºæ™¯æµ‹è¯•

## 11. éƒ¨ç½²é…ç½®

### 11.1 ç¯å¢ƒå˜é‡

```bash
# AIæœåŠ¡é…ç½®
OPENAI_API_KEY=your_openai_api_key
PINECONE_API_KEY=your_pinecone_api_key
PINECONE_ENVIRONMENT=your_pinecone_environment
PINECONE_INDEX_NAME=knowledge_base

# æ•°æ®åº“é…ç½®
DATABASE_URL=postgresql://user:password@localhost:5432/knowledge_db
REDIS_URL=redis://localhost:6379

# æ–‡ä»¶å­˜å‚¨é…ç½®
FILE_STORAGE_TYPE=s3
AWS_S3_BUCKET=knowledge-files
AWS_ACCESS_KEY_ID=your_aws_access_key
AWS_SECRET_ACCESS_KEY=your_aws_secret_key

# æœç´¢é…ç½®
MAX_SEARCH_RESULTS=50
SEARCH_CACHE_TTL=300

# AIé…ç½®
AI_PROCESSING_ENABLED=true
MAX_DOCUMENT_SIZE=10485760
AI_SUMMARY_MAX_LENGTH=200
```

### 11.2 Dockeré…ç½®

```dockerfile
# Dockerfile.knowledge
FROM node:18-alpine

WORKDIR /app

# å®‰è£…ä¾èµ–
COPY package*.json ./
RUN npm ci --only=production

# å¤åˆ¶æºä»£ç 
COPY . .

# æ„å»ºåº”ç”¨
RUN npm run build

# æš´éœ²ç«¯å£
EXPOSE 3000

# å¯åŠ¨åº”ç”¨
CMD ["npm", "start"]
```

## 12. æ€»ç»“

AIçŸ¥è¯†åº“é¡µé¢æ˜¯ä¸€ä¸ªåŠŸèƒ½ä¸°å¯Œçš„æ™ºèƒ½æ–‡æ¡£ç®¡ç†ç³»ç»Ÿï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

- **æ™ºèƒ½åŒ–**: åŸºäºLangChainå’ŒLangGraphçš„AIå¢å¼ºåŠŸèƒ½
- **é«˜æ€§èƒ½**: ä¼˜åŒ–çš„æœç´¢å’Œæ¸²æŸ“æ€§èƒ½
- **ç”¨æˆ·å‹å¥½**: ç›´è§‚çš„ç•Œé¢è®¾è®¡å’Œäº¤äº’ä½“éªŒ
- **å¯æ‰©å±•**: æ¨¡å—åŒ–çš„æ¶æ„è®¾è®¡
- **å®‰å…¨å¯é **: å®Œå–„çš„æƒé™æ§åˆ¶å’Œé”™è¯¯å¤„ç†

è¯¥è®¾è®¡æ–‡æ¡£ä¸ºå¼€å‘å›¢é˜Ÿæä¾›äº†å®Œæ•´çš„æŠ€æœ¯å®ç°æŒ‡å—ï¼Œç¡®ä¿é¡¹ç›®çš„é«˜è´¨é‡äº¤ä»˜ã€‚
